===== LICENSE =====
MIT License

Copyright (c) 2023 Kevin Silvester

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===== README.md =====
<h2 align="center">My WezTerm Config</h2>

<p align="center">
  <a href="https://github.com/KevinSilvester/wezterm-config/stargazers">
    <img alt="Stargazers" src="https://img.shields.io/github/stars/KevinSilvester/wezterm-config?style=for-the-badge&logo=starship&color=C9CBFF&logoColor=D9E0EE&labelColor=302D41">
  </a>
  <a href="https://github.com/KevinSilvester/wezterm-config/issues">
    <img alt="Issues" src="https://img.shields.io/github/issues/KevinSilvester/wezterm-config?style=for-the-badge&logo=gitbook&color=B5E8E0&logoColor=D9E0EE&labelColor=302D41">
  </a>
  <a href="https://github.com/KevinSilvester/wezterm-config/actions/workflows/lint.yml">
    <img alt="Build" src="https://img.shields.io/github/actions/workflow/status/KevinSilvester/wezterm-config/lint.yml?&style=for-the-badge&logo=githubactions&label=CI&color=A6E3A1&logoColor=D9E0EE&labelColor=302D41">
  </a>
</p>

![screenshot](./.github/screenshots/wezterm.gif)

---

### Features

- [**Background Image Selector**](https://github.com/KevinSilvester/wezterm-config/blob/master/utils/backdrops.lua)

  - Cycle images
  - Fuzzy search for image
  - Toggle background image

  > See: [key bindings](#background-images) for usage

- [**GPU Adapter Selector**](https://github.com/KevinSilvester/wezterm-config/blob/master/utils/gpu_adapter.lua)

  > :bulb: Only works if the [`front_end`](https://github.com/KevinSilvester/wezterm-config/blob/master/config/appearance.lua#L8) option is set to `WebGpu`.

  A small utility to select the best GPU + Adapter (graphics API) combo for your machine.

  GPU + Adapter combo is selected based on the following criteria:

  1.  <details>
      <summary>Best GPU available</summary>

      `Discrete` > `Integrated` > `Other` (for `wgpu`'s OpenGl implementation on Discrete GPU) > `Cpu`
      </details>

  2.  <details>
      <summary>Best graphics API available (based off my very scientific scroll a big log file in Neovim test üòÅ)</summary>

      > :bulb:<br>
      > The available graphics API choices change based on your OS.<br>
      > These options correspond to the APIs the `wgpu` crate (which powers WezTerm's gui in `WebGpu` mode)<br>
      > currently has support implemented for.<br>
      > See: <https://github.com/gfx-rs/wgpu#supported-platforms> for more info

      - Windows: `Dx12` > `Vulkan` > `OpenGl`
      - Linux: `Vulkan` > `OpenGl`
      - Mac: `Metal`

      </details>

---

### Getting Started

- ##### Requirements:

  - <details>
      <summary><b>WezTerm</b></summary>

    Minimum Version: `20240127-113634-bbcac864`<br>
    Recommended Version: [`Nightly`](https://github.com/wez/wezterm/releases/nightly)

    [Official Installation Page](https://wezfurlong.org/wezterm/installation.html)

    **Windows**

    - <details>
      <summary>Install Stable</summary>

      - Install with Scoop (non-portable)

        ```sh
        scoop bucket add extras
        scoop install wezterm
        ```

      - Install with Scoop (portable)

        ```sh
        scoop bucket add k https://github.com/KevinSilvester/scoop-bucket
        scoop install k/wezterm
        ```

      - Install with winget

        ```sh
        winget install wez.wezterm
        ```

      - Install with choco

        ```sh
        choco install wezterm -y
        ```
      </details>

    - <details>
      <summary>Install Nightly</summary>

      - Install with Scoop (non-portable)

        ```sh
        scoop bucket add versions
        scoop install wezterm-nightly
        ```

      - Install with Scoop (portable)

        ```sh
        scoop bucket add k https://github.com/KevinSilvester/scoop-bucket
        scoop install k/wezterm-nightly
        ```
      </details>

    > :bulb:<br>
    > Toast notifications don't work in non-portable installations.<br>
    > See issue <https://github.com/wez/wezterm/issues/5166> for more details
  
    ---

    **MacOS**

    - <details>
      <summary>Install Stable</summary>

      - Install with Homebrew

        ```sh
        brew install --cask wezterm
        ```

      - Install with MacPort

        ```sh
        sudo port selfupdate
        sudo port install wezterm
        ```
      </details>

    - <details>
      <summary>Install Nighlty</summary>

      - Install with Homebrew

        ```sh
        brew install --cask wezterm@nightly
        ```

      - Upgrade with Homebrew

        ```sh
        brew install --cask wezterm@nightly --no-quarantine --greedy-latest
        ```
      </details>

    ---

    **Linux**

    Refer to the Linux installation page.<br>
    <https://wezfurlong.org/wezterm/install/linux.html>

    </details>

  - <details>
    <summary>JetBrainsMono Nerd Font</summary>

    Install with Homebrew (Macos)

    ```sh
    brew tap homebrew/cask-fonts
    brew install font-jetbrains-mono-nerd-font
    ```

    Install with Scoop (Windows)

    ```sh
    scoop bucket add nerd-fonts
    scoop install JetBrainsMono-NF
    ```

    > More Info:
    >
    > - <https://www.nerdfonts.com/#home>
    > - <https://github.com/ryanoasis/nerd-fonts?#font-installation>
    </details/>

&nbsp;

- ##### Steps:

  1.  ```sh
      # On Windows and Unix systems
      git clone https://github.com/KevinSilvester/wezterm-config.git ~/.config/wezterm
      ```
  2.  And Done!!! üéâüéâ

&nbsp;

- ##### Things You Might Want to Change:

  - [./config/domains.lua](./config/domains.lua) for custom SSH/WSL domains
  - [./config/launch.lua](./config/launch.lua) for preferred shells and its paths

---

### All Key Bindings

Most of the key bindings revolve around a <kbd>SUPER</kbd> and <kbd>SUPER_REV</kbd>(super reversed) keys.<br>

- On MacOs:
  - <kbd>SUPER</kbd> ‚á® <kbd>Super</kbd>
  - <kbd>SUPER_REV</kbd> ‚á® <kbd>Super</kbd>+<kbd>Ctrl</kbd>
- On Windows and Linux
  - <kbd>SUPER</kbd> ‚á® <kbd>Alt</kbd>
  - <kbd>SUPER_REV</kbd> ‚á® <kbd>Alt</kbd>+<kbd>Ctrl</kbd>

> To avoid confusion when switching between different OS and to avoid conflicting<br>
> with OS's built-in keyboard shortcuts.

- On all platforms: <kbd>LEADER</kbd> ‚á® <kbd>SUPER_REV</kbd>+<kbd>Space</kbd>

#### Miscellaneous/Useful

| Keys                              | Action                                      |
| --------------------------------- | ------------------------------------------- |
| <kbd>F1</kbd>                     | `ActivateCopyMode`                          |
| <kbd>F2</kbd>                     | `ActivateCommandPalette`                    |
| <kbd>F3</kbd>                     | `ShowLauncher`                              |
| <kbd>F4</kbd>                     | `ShowLauncher` <sub>(tabs only)</sub>       |
| <kbd>F5</kbd>                     | `ShowLauncher` <sub>(workspaces only)</sub> |
| <kbd>F11</kbd>                    | `ToggleFullScreen`                          |
| <kbd>F12</kbd>                    | `ShowDebugOverlay`                          |
| <kbd>SUPER</kbd>+<kbd>f</kbd>     | Search Text                                 |
| <kbd>SUPER_REV</kbd>+<kbd>u</kbd> | Open URL                                    |

&nbsp;

#### Copy+Paste

| Keys                                          | Action               |
| --------------------------------------------- | -------------------- |
| <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>c</kbd> | Copy to Clipboard    |
| <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>v</kbd> | Paste from Clipboard |

&nbsp;

#### Cursor Movements

| Keys                                   | Action                                                     |
| -------------------------------------- | ---------------------------------------------------------- |
| <kbd>SUPER</kbd>+<kbd>LeftArrow</kbd>  | Move cursor to Line Start                                  |
| <kbd>SUPER</kbd>+<kbd>RightArrow</kbd> | Move cursor to Line End                                    |
| <kbd>SUPER</kbd>+<kbd>Backspace</kbd>  | Clear Line <sub>(does not work in PowerShell or cmd)</sub> |

&nbsp;

#### Tabs

##### Tabs: Spawn+Close

| Keys                              | Action                                |
| --------------------------------- | ------------------------------------- |
| <kbd>SUPER</kbd>+<kbd>t</kbd>     | `SpawnTab` <sub>(DefaultDomain)</sub> |
| <kbd>SUPER_REV</kbd>+<kbd>t</kbd> | `SpawnTab` <sub>(WSL:Ubuntu)</sub>    |
| <kbd>SUPER_REV</kbd>+<kbd>w</kbd> | `CloseCurrentTab`                     |

##### Tabs: Navigation

| Keys                              | Action         |
| --------------------------------- | -------------- |
| <kbd>SUPER</kbd>+<kbd>[</kbd>     | Next Tab       |
| <kbd>SUPER</kbd>+<kbd>]</kbd>     | Previous Tab   |
| <kbd>SUPER_REV</kbd>+<kbd>[</kbd> | Move Tab Left  |
| <kbd>SUPER_REV</kbd>+<kbd>]</kbd> | Move Tab Right |

##### Tabs: Toggle Tab-bar

| Keys                          | Action         |
| ----------------------------- | -------------- |
| <kbd>SUPER</kbd>+<kbd>9</kbd> | Toggle tab bar |

##### Tabs: Title

| Keys                              | Action             |
| --------------------------------- | ------------------ |
| <kbd>SUPER</kbd>+<kbd>0</kbd>     | Rename Current Tab |
| <kbd>SUPER_REV</kbd>+<kbd>0</kbd> | Undo Rename        |

&nbsp;

#### Windows

| Keys                          | Action               |
| ----------------------------- | -------------------- |
| <kbd>SUPER</kbd>+<kbd>n</kbd> | `SpawnWindow`        |
| <kbd>SUPER</kbd>+<kbd>=</kbd> | Increase Window Size |
| <kbd>SUPER</kbd>+<kbd>-</kbd> | Decrease Window Size |

&nbsp;

#### Panes

##### Panes: Split Panes

| Keys                               | Action                                           |
| ---------------------------------- | ------------------------------------------------ |
| <kbd>SUPER</kbd>+<kbd>\\</kbd>     | `SplitVertical` <sub>(CurrentPaneDomain)</sub>   |
| <kbd>SUPER_REV</kbd>+<kbd>\\</kbd> | `SplitHorizontal` <sub>(CurrentPaneDomain)</sub> |

##### Panes: Zoom+Close Pane

| Keys                              | Action                |
| --------------------------------- | --------------------- |
| <kbd>SUPER</kbd>+<kbd>Enter</kbd> | `TogglePaneZoomState` |
| <kbd>SUPER</kbd>+<kbd>w</kbd>     | `CloseCurrentPane`    |

##### Panes: Navigation

| Keys                              | Action                  |
| --------------------------------- | ----------------------- |
| <kbd>SUPER_REV</kbd>+<kbd>k</kbd> | Move to Pane (Up)       |
| <kbd>SUPER_REV</kbd>+<kbd>j</kbd> | Move to Pane (Down)     |
| <kbd>SUPER_REV</kbd>+<kbd>h</kbd> | Move to Pane (Left)     |
| <kbd>SUPER_REV</kbd>+<kbd>l</kbd> | Move to Pane (Right)    |
| <kbd>SUPER_REV</kbd>+<kbd>p</kbd> | Swap with selected Pane |

##### Panes: Scroll Pane

| Keys                          | Action                               |
| ----------------------------- | ------------------------------------ |
| <kbd>SUPER</kbd>+<kbd>u</kbd> | Scroll Lines up <sub>5 lines</sub>   |
| <kbd>SUPER</kbd>+<kbd>d</kbd> | Scroll Lines down <sub>5 lines</sub> |
| <kbd>PageUp</kbd>             | Scroll Page up                       |
| <kbd>PageDown</kbd>           | Scroll Page down                     |

&nbsp;

#### Background Images

| Keys                              | Action                       |
| --------------------------------- | ---------------------------- |
| <kbd>SUPER</kbd>+<kbd>/</kbd>     | Select Random Image          |
| <kbd>SUPER</kbd>+<kbd>,</kbd>     | Cycle to next Image          |
| <kbd>SUPER</kbd>+<kbd>.</kbd>     | Cycle to previous Image      |
| <kbd>SUPER_REV</kbd>+<kbd>/</kbd> | Fuzzy select Image           |
| <kbd>SUPER</kbd>+<kbd>b</kbd>     | Toggle background focus mode |

&nbsp;

#### Key Tables

> See: <https://wezfurlong.org/wezterm/config/key-tables.html>

| Keys                           | Action        |
| ------------------------------ | ------------- |
| <kbd>LEADER</kbd>+<kbd>f</kbd> | `resize_font` |
| <kbd>LEADER</kbd>+<kbd>p</kbd> | `resize_pane` |

##### Key Table: `resize_font`

| Keys           | Action                          |
| -------------- | ------------------------------- |
| <kbd>k</kbd>   | `IncreaseFontSize`              |
| <kbd>j</kbd>   | `DecreaseFontSize`              |
| <kbd>r</kbd>   | `ResetFontSize`                 |
| <kbd>q</kbd>   | `PopKeyTable` <sub>(exit)</sub> |
| <kbd>Esc</kbd> | `PopKeyTable` <sub>(exit)</sub> |

##### Key Table: `resize_pane`

| Keys           | Action                                         |
| -------------- | ---------------------------------------------- |
| <kbd>k</kbd>   | `AdjustPaneSize` <sub>(Direction: Up)</sub>    |
| <kbd>j</kbd>   | `AdjustPaneSize` <sub>(Direction: Down)</sub>  |
| <kbd>h</kbd>   | `AdjustPaneSize` <sub>(Direction: Left)</sub>  |
| <kbd>l</kbd>   | `AdjustPaneSize` <sub>(Direction: Right)</sub> |
| <kbd>q</kbd>   | `PopKeyTable` <sub>(exit)</sub>                |
| <kbd>Esc</kbd> | `PopKeyTable` <sub>(exit)</sub>                |

---

### References/Inspirations

- <https://github.com/rxi/lume>
- <https://github.com/catppuccin/wezterm>
- <https://github.com/wez/wezterm/discussions/628#discussioncomment-1874614>
- <https://github.com/wez/wezterm/discussions/628#discussioncomment-5942139>

===== archive/codex.lua =====
# Codex AI Color Scheme - Soft Purple/Teal Theme
# Primary: #9B7CD5 (Soft Purple), Accent: #7BA3D4 (Soft Teal)

[metadata]
name = "Codex"
author = "WezTerm AI Setup"

[colors]
foreground = "#E4E4E8"
background = "#12121A"
cursor_bg = "#9B7CD5"
cursor_fg = "#12121A"
cursor_border = "#9B7CD5"
selection_bg = "#2D2944"
selection_fg = "#E4E4E8"

# Normal colors
ansi = [
    "#1A1A24",  # black
    "#D47A8C",  # red (soft rose)
    "#7BD4A4",  # green (soft mint)
    "#D4C47A",  # yellow (soft gold)
    "#7BA3D4",  # blue (accent - soft teal)
    "#9B7CD5",  # magenta (primary - soft purple)
    "#7AD4D4",  # cyan (soft aqua)
    "#C8C8D0",  # white
]

# Bright colors
brights = [
    "#2E2E3E",  # bright black
    "#E494A6",  # bright red
    "#95E4BE",  # bright green
    "#E4D494",  # bright yellow
    "#95BDE4",  # bright blue
    "#B596E5",  # bright magenta
    "#94E4E4",  # bright cyan
    "#E4E4E8",  # bright white
]

[colors.tab_bar]
background = "#12121A"

[colors.tab_bar.active_tab]
bg_color = "#9B7CD5"
fg_color = "#12121A"

[colors.tab_bar.inactive_tab]
bg_color = "#1A1A24"
fg_color = "#C8C8D0"

===== archive/profiles.lua =====
-- CLI Profile Definitions for AI Tools
-- Each profile has unique colors, fonts, and window settings

local wezterm = require('wezterm')
local platform = require('utils.platform')

local M = {}

-- Get home directory in a cross-platform way
local home = wezterm.home_dir

local codex_cmd = { 'codex' }
local codex_domain = nil

if platform.is_win then
   -- Run exclusively in WSL on Windows
   codex_domain = { DomainName = 'WSL:Ubuntu' }
end

-- Profile definitions for each AI CLI
M.profiles = {
   claude = {
      name = 'Claude',
      color_scheme = 'Claude',
      font = 'Hurmit Nerd Font',
      window_title = 'Claude',
      cli_command = { home .. '/.local/bin/claude' },
      env = { CLI_PROFILE = 'claude' },
      cursor_color = '#C15F3C',
   },
   gemini = {
      name = 'Gemini',
      color_scheme = 'Gemini',
      font = 'EnvyCodeR Nerd Font',
      window_title = 'Gemini',
      cli_command = { '/usr/local/bin/gemini' },
      env = { CLI_PROFILE = 'gemini' },
      cursor_color = '#4285F4',
   },
   grok = {
      name = 'Grok',
      color_scheme = 'Grok',
      font = 'CaskaydiaCove Nerd Font',
      window_title = 'Grok',
      cli_command = { home .. '/.bun/bin/grok' },
      env = { CLI_PROFILE = 'grok' },
      cursor_color = '#FF007F',
   },
   codex = {
      name = 'Codex',
      color_scheme = 'Codex',
      font = 'SpaceMono Nerd Font',
      window_title = 'Codex',
      cli_command = codex_cmd,  -- Assumes npm global install or in PATH
      domain = codex_domain,
      env = { CLI_PROFILE = 'codex' },
      cursor_color = '#9B7CD5',
   },
}

-- Create a SpawnCommand for a profile
function M.spawn_command(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      wezterm.log_error('Unknown profile: ' .. tostring(profile_name))
      return nil
   end

   return {
      args = profile.cli_command,
      set_environment_variables = profile.env,
      domain = profile.domain,
   }
end

-- Get profile-specific window configuration
function M.get_window_config(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      return {}
   end

   return {
      color_scheme = profile.color_scheme,
      font = wezterm.font(profile.font),
      window_frame = {
         font = wezterm.font(profile.font),
      },
   }
end

-- Action to spawn a new window with a specific profile
function M.spawn_profile_action(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      return wezterm.action.Nop
   end

   return wezterm.action_callback(function(window, pane)
      local spawn_cmd = M.spawn_command(profile_name)
      if spawn_cmd then
         -- Spawn in a new window with profile-specific settings
         wezterm.mux.spawn_window({
            args = spawn_cmd.args,
            set_environment_variables = spawn_cmd.set_environment_variables,
            domain = spawn_cmd.domain,
            cwd = pane:get_current_working_dir(),
         })
      end
   end)
end

return M

===== colors/CHANGELOD.md =====
# Changelog

- Updated ANSI/bright palettes in `custom.lua` to a CGA-inspired 70s/80s theme.
- Darkened `colorscheme.background` in `custom.lua` to `rgba(8, 8, 12, 0.85)` for higher contrast while retaining transparency.
- Increased macOS window blur in `../config/appearance.lua` to `5`.
- Increased window background opacity in `../config/appearance.lua` to `0.90`.
- Increased text background opacity in `../config/appearance.lua` to `0.95`.
- Updated default font in `../config/fonts.lua` to `Hack Nerd Font Mono`, weight `Regular`, size `13` on macOS.

===== colors/claude.toml =====
# Claude AI Color Scheme - Rust/Terracotta Theme
# Primary: #C15F3C (Rust), Accent: #CC785C (Antique Brass)

[metadata]
name = "Claude"
author = "WezTerm AI Setup"

[colors]
foreground = "#E8DED5"
background = "#1A1512"
cursor_bg = "#C15F3C"
cursor_fg = "#1A1512"
cursor_border = "#C15F3C"
selection_bg = "#3D2A22"
selection_fg = "#E8DED5"

# Normal colors
ansi = [
    "#2D2119",  # black
    "#C15F3C",  # red (primary)
    "#8B9A5B",  # green
    "#D4A656",  # yellow
    "#7A9BB5",  # blue
    "#B07A8C",  # magenta
    "#6B9B8A",  # cyan
    "#C4B5A5",  # white
]

# Bright colors
brights = [
    "#4A3D32",  # bright black
    "#CC785C",  # bright red (accent)
    "#A4B574",  # bright green
    "#E5C078",  # bright yellow
    "#94B5CF",  # bright blue
    "#C994A6",  # bright magenta
    "#85B5A4",  # bright cyan
    "#E8DED5",  # bright white
]

[colors.tab_bar]
background = "#1A1512"

[colors.tab_bar.active_tab]
bg_color = "#C15F3C"
fg_color = "#1A1512"

[colors.tab_bar.inactive_tab]
bg_color = "#2D2119"
fg_color = "#C4B5A5"

===== colors/codex.toml =====
# Codex AI Color Scheme - Soft Purple/Teal Theme
# Primary: #9B7CD5 (Soft Purple), Accent: #7BA3D4 (Soft Teal)

[metadata]
name = "Codex"
author = "WezTerm AI Setup"

[colors]
foreground = "#E4E4E8"
background = "#12121A"
cursor_bg = "#9B7CD5"
cursor_fg = "#12121A"
cursor_border = "#9B7CD5"
selection_bg = "#2D2944"
selection_fg = "#E4E4E8"

# Normal colors
ansi = [
    "#1A1A24",  # black
    "#D47A8C",  # red (soft rose)
    "#7BD4A4",  # green (soft mint)
    "#D4C47A",  # yellow (soft gold)
    "#7BA3D4",  # blue (accent - soft teal)
    "#9B7CD5",  # magenta (primary - soft purple)
    "#7AD4D4",  # cyan (soft aqua)
    "#C8C8D0",  # white
]

# Bright colors
brights = [
    "#2E2E3E",  # bright black
    "#E494A6",  # bright red
    "#95E4BE",  # bright green
    "#E4D494",  # bright yellow
    "#95BDE4",  # bright blue
    "#B596E5",  # bright magenta
    "#94E4E4",  # bright cyan
    "#E4E4E8",  # bright white
]

[colors.tab_bar]
background = "#12121A"

[colors.tab_bar.active_tab]
bg_color = "#9B7CD5"
fg_color = "#12121A"

[colors.tab_bar.inactive_tab]
bg_color = "#1A1A24"
fg_color = "#C8C8D0"

===== colors/custom.lua =====
-- Custom Nord Bright (Matching Windows Terminal)
-- stylua: ignore
local nord = {
   background = '#2E3440',
   foreground = '#E5E9F0',
   cursor     = '#D4A04A',
   selection  = '#EBCB8B',

   black      = '#B87A94', -- Specific pinkish black from your config
   red        = '#EC5F67',
   green      = '#7DEBA5',
   yellow     = '#EBCB8B',
   blue       = '#61AFEF',
   purple     = '#D4BFFF',
   cyan       = '#9AEDFE',
   white      = '#FFFFFF',

   brightBlack  = '#D4A0B0', -- Specific pinkish bright black
   brightRed    = '#FF8B92',
   brightGreen  = '#8FBCBB',
   brightYellow = '#FFEC8B',
   brightBlue   = '#81A1C1',
   brightPurple = '#FF92DF',
   brightCyan   = '#A4FFFF',
   brightWhite  = '#FFFFFF',
}

local colorscheme = {
   foreground = nord.foreground,
   background = nord.background,
   cursor_bg = nord.cursor,
   cursor_border = nord.cursor,
   cursor_fg = nord.background,
   selection_bg = nord.selection,
   selection_fg = nord.background,

   ansi = {
      nord.black,
      nord.red,
      nord.green,
      nord.yellow,
      nord.blue,
      nord.purple,
      nord.cyan,
      nord.white,
   },
   brights = {
      nord.brightBlack,
      nord.brightRed,
      nord.brightGreen,
      nord.brightYellow,
      nord.brightBlue,
      nord.brightPurple,
      nord.brightCyan,
      nord.brightWhite,
   },

   tab_bar = {
      background = '#242933', -- Matching "tabRow" from your JSON
      active_tab = {
         bg_color = '#2E3440', -- Matching "tab.background"
         fg_color = nord.foreground,
      },
      inactive_tab = {
         bg_color = '#3B4252', -- Matching "unfocusedBackground"
         fg_color = '#D8DEE9',
      },
      inactive_tab_hover = {
         bg_color = '#434C5E',
         fg_color = nord.foreground,
      },
      new_tab = {
         bg_color = '#3B4252',
         fg_color = nord.foreground,
      },
      new_tab_hover = {
         bg_color = '#434C5E',
         fg_color = nord.cursor,
         italic = true,
      },
   },
   visual_bell = nord.red,
   indexed = {
      [16] = '#D08770', -- Peach
      [17] = nord.cursor,
   },
   scrollbar_thumb = '#4C566A',
   split = '#3B4252',
   compose_cursor = nord.cursor,
}

return colorscheme

===== colors/gemini.toml =====
# Gemini AI Color Scheme - Google Blue/Green Theme
# Primary: #4285F4 (Google Blue), Accent: #34A853 (Google Green)

[metadata]
name = "Gemini"
author = "WezTerm AI Setup"

[colors]
foreground = "#E8EAED"
background = "#0D1117"
cursor_bg = "#4285F4"
cursor_fg = "#0D1117"
cursor_border = "#4285F4"
selection_bg = "#1F3354"
selection_fg = "#E8EAED"

# Normal colors
ansi = [
    "#161B22",  # black
    "#EA4335",  # red (Google Red)
    "#34A853",  # green (Google Green - accent)
    "#FBBC04",  # yellow (Google Yellow)
    "#4285F4",  # blue (primary)
    "#A142F4",  # magenta (Google Purple)
    "#24C1E0",  # cyan (Google Cyan)
    "#C9D1D9",  # white
]

# Bright colors
brights = [
    "#30363D",  # bright black
    "#F28B82",  # bright red
    "#81C995",  # bright green
    "#FDD663",  # bright yellow
    "#8AB4F8",  # bright blue
    "#C58AF9",  # bright magenta
    "#78D9EC",  # bright cyan
    "#E8EAED",  # bright white
]

[colors.tab_bar]
background = "#0D1117"

[colors.tab_bar.active_tab]
bg_color = "#4285F4"
fg_color = "#0D1117"

[colors.tab_bar.inactive_tab]
bg_color = "#161B22"
fg_color = "#C9D1D9"

===== colors/grok.toml =====
# Grok AI Color Scheme - Cyberpunk Neon Theme
# Primary: #FF007F (Neon Magenta), Accent: #00FFFF (Neon Cyan)

[metadata]
name = "Grok"
author = "WezTerm AI Setup"

[colors]
foreground = "#F0F0F0"
background = "#0A0A0F"
cursor_bg = "#FF007F"
cursor_fg = "#0A0A0F"
cursor_border = "#FF007F"
selection_bg = "#3D1A2D"
selection_fg = "#F0F0F0"

# Normal colors
ansi = [
    "#121218",  # black
    "#FF007F",  # red (primary - neon magenta)
    "#00FF9F",  # green (neon green)
    "#FFE600",  # yellow (neon yellow)
    "#00B4FF",  # blue (neon blue)
    "#BD00FF",  # magenta (neon purple)
    "#00FFFF",  # cyan (accent - neon cyan)
    "#D0D0D0",  # white
]

# Bright colors
brights = [
    "#2A2A35",  # bright black
    "#FF4D9F",  # bright red
    "#4DFFBF",  # bright green
    "#FFEB4D",  # bright yellow
    "#4DC9FF",  # bright blue
    "#D44DFF",  # bright magenta
    "#4DFFFF",  # bright cyan
    "#F0F0F0",  # bright white
]

[colors.tab_bar]
background = "#0A0A0F"

[colors.tab_bar.active_tab]
bg_color = "#FF007F"
fg_color = "#0A0A0F"

[colors.tab_bar.inactive_tab]
bg_color = "#121218"
fg_color = "#D0D0D0"

===== config/appearance.lua =====
local gpu_adapters = require('utils.gpu-adapter')
local colors = require('colors.custom')
local starlight = require('config.starlight')

return {
   max_fps = 120,
   front_end = 'WebGpu', ---@type 'WebGpu' | 'OpenGL' | 'Software'
   webgpu_power_preference = 'HighPerformance',
   webgpu_preferred_adapter = gpu_adapters:pick_best(),
   -- webgpu_preferred_adapter = gpu_adapters:pick_manual('Dx12', 'IntegratedGpu'),
   -- webgpu_preferred_adapter = gpu_adapters:pick_manual('Gl', 'Other'),
   underline_thickness = '1.5pt',

   -- cursor
   animation_fps = 120,
   cursor_blink_ease_in = 'EaseOut',
   cursor_blink_ease_out = 'EaseOut',
   default_cursor_style = 'SteadyBlock', -- Fixed: "FilledBox" -> "SteadyBlock"
   cursor_blink_rate = 650,

   -- color scheme
   colors = colors,

   -- background: solid color matching Windows Terminal
   background = {
      {
         source = { Color = '#2E3440' },  -- Nord base color
         height = '100%',
         width = '100%',
         opacity = 0.85,
      },
   },

   -- scrollbar
   enable_scroll_bar = true,

   -- tab bar
   enable_tab_bar = true,
   hide_tab_bar_if_only_one_tab = false,
   use_fancy_tab_bar = false,
   tab_max_width = 25,
   show_tab_index_in_tab_bar = false,
   switch_to_last_active_tab_when_closing_tab = true,

   -- command palette
   command_palette_fg_color = starlight.palette.fg,
   command_palette_bg_color = starlight.palette.bg,
   command_palette_font_size = 12,
   command_palette_rows = 25,

   -- window
   window_decorations = 'TITLE | RESIZE',
   window_padding = {
      left = 8,
      right = 8,
      top = 8,
      bottom = 8,
   },
   adjust_window_size_when_changing_font_size = false,
   window_close_confirmation = 'NeverPrompt',

   -- Matching Windows Terminal opacity (85%)
   window_background_opacity = 0.85,
   text_background_opacity = 1.0,
   macos_window_background_blur = 5,
   window_frame = {
      active_titlebar_bg = '#242933',  -- Nord mantle color
      -- font = fonts.font,
      -- font_size = fonts.font_size,
   },
   -- inactive_pane_hsb = {
   --    saturation = 0.9,
   --    brightness = 0.65,
   -- },
   inactive_pane_hsb = {
      saturation = 1,
      brightness = 1,
   },

   visual_bell = {
      fade_in_function = 'EaseIn',
      fade_in_duration_ms = 250,
      fade_out_function = 'EaseOut',
      fade_out_duration_ms = 250,
      target = 'CursorColor',
   },
}

===== config/bindings.lua =====
local wezterm = require('wezterm')
local platform = require('utils.platform')
local backdrops = require('utils.backdrops')
local profiles = require('config.profiles')
local act = wezterm.action

local mod = {}

if platform.is_mac then
   mod.SUPER = 'SUPER'
   mod.SUPER_REV = 'SUPER|CTRL'
elseif platform.is_win or platform.is_linux then
   mod.SUPER = 'ALT' -- to not conflict with Windows key shortcuts
   mod.SUPER_REV = 'ALT|CTRL'
end

-- stylua: ignore
local keys = {
   -- misc/useful --
   { key = 'F1', mods = 'NONE', action = 'ActivateCopyMode' },
   { key = 'F2', mods = 'NONE', action = act.ActivateCommandPalette },
   { key = 'F3', mods = 'NONE', action = act.ShowLauncher },
   { key = 'F4', mods = 'NONE', action = act.ShowLauncherArgs({ flags = 'FUZZY|TABS' }) },
   {
      key = 'F5',
      mods = 'NONE',
      action = act.ShowLauncherArgs({ flags = 'FUZZY|WORKSPACES' }),
   },
   { key = 'F11', mods = 'NONE',    action = act.ToggleFullScreen },
   { key = 'F12', mods = 'NONE',    action = act.ShowDebugOverlay },
   { key = 'f',   mods = mod.SUPER, action = act.Search({ CaseInSensitiveString = '' }) },
   {
      key = 'u',
      mods = mod.SUPER_REV,
      action = wezterm.action.QuickSelectArgs({
         label = 'open url',
         patterns = {
            '\\((https?://\\S+)\\)',
            '\\[(https?://\\S+)\\]',
            '\\{(https?://\\S+)\\}',
            '<(https?://\\S+)>',
            '\\bhttps?://\\S+[)/a-zA-Z0-9-]+'
         },
         action = wezterm.action_callback(function(window, pane)
            local url = window:get_selection_text_for_pane(pane)
            wezterm.log_info('opening: ' .. url)
            wezterm.open_with(url)
         end),
      }),
   },

   -- cursor movement --
   { key = 'LeftArrow',  mods = mod.SUPER,     action = act.SendString '\u{1b}OH' },
   { key = 'RightArrow', mods = mod.SUPER,     action = act.SendString '\u{1b}OF' },
   { key = 'Backspace',  mods = mod.SUPER,     action = act.SendString '\u{15}' },

   -- copy/paste --
   { key = 'c',          mods = 'CTRL|SHIFT',  action = act.CopyTo('Clipboard') },
   { key = 'v',          mods = 'CTRL|SHIFT',  action = act.PasteFrom('Clipboard') },

   -- tabs --
   -- tabs: spawn+close
   { key = 't',          mods = mod.SUPER,     action = act.SpawnTab('DefaultDomain') },
   { key = 't',          mods = mod.SUPER_REV, action = act.SpawnTab({ DomainName = 'wsl:ubuntu-fish' }) },
   { key = 'w',          mods = mod.SUPER_REV, action = act.CloseCurrentTab({ confirm = false }) },

   -- tabs: navigation
   { key = '[',          mods = mod.SUPER,     action = act.ActivateTabRelative(-1) },
   { key = ']',          mods = mod.SUPER,     action = act.ActivateTabRelative(1) },
   { key = '[',          mods = mod.SUPER_REV, action = act.MoveTabRelative(-1) },
   { key = ']',          mods = mod.SUPER_REV, action = act.MoveTabRelative(1) },

   -- tab: title
   { key = '0',          mods = mod.SUPER,     action = act.EmitEvent('tabs.manual-update-tab-title') },
   { key = '0',          mods = mod.SUPER_REV, action = act.EmitEvent('tabs.reset-tab-title') },

   -- tab: hide tab-bar
   { key = '9',          mods = mod.SUPER,     action = act.EmitEvent('tabs.toggle-tab-bar'), },

   -- window --
   -- window: spawn windows
   { key = 'n',          mods = mod.SUPER,     action = act.SpawnWindow },

   -- window: zoom window
   {
      key = '-',
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         local dimensions = window:get_dimensions()
         if dimensions.is_full_screen then
            return
         end
         local new_width = dimensions.pixel_width - 50
         local new_height = dimensions.pixel_height - 50
         window:set_inner_size(new_width, new_height)
      end)
   },
   {
      key = '=',
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         local dimensions = window:get_dimensions()
         if dimensions.is_full_screen then
            return
         end
         local new_width = dimensions.pixel_width + 50
         local new_height = dimensions.pixel_height + 50
         window:set_inner_size(new_width, new_height)
      end)
   },
   {
      key = 'Enter',
      mods = mod.SUPER_REV,
      action = wezterm.action_callback(function(window, _pane)
         window:maximize()
      end)
   },

   -- background controls --
   {
      key = [[/]],
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         backdrops:random(window)
      end),
   },
   {
      key = [[,]],
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         backdrops:cycle_back(window)
      end),
   },
   {
      key = [[.]],
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         backdrops:cycle_forward(window)
      end),
   },
   {
      key = [[/]],
      mods = mod.SUPER_REV,
      action = act.InputSelector({
         title = 'InputSelector: Select Background',
         choices = backdrops:choices(),
         fuzzy = true,
         fuzzy_description = 'Select Background: ',
         action = wezterm.action_callback(function(window, _pane, idx)
            if not idx then
               return
            end
            ---@diagnostic disable-next-line: param-type-mismatch
            backdrops:set_img(window, tonumber(idx))
         end),
      }),
   },
   {
      key = 'b',
      mods = mod.SUPER,
      action = wezterm.action_callback(function(window, _pane)
         backdrops:toggle_focus(window)
      end)
   },

   -- key-tables --
   -- resizes fonts
   {
      key = 'f',
      mods = 'LEADER',
      action = act.ActivateKeyTable({
         name = 'resize_font',
         one_shot = false,
         timemout_milliseconds = 1000,
      }),
   },

   -- AI CLI Launchers (Ctrl+Alt+C/G/R/X) --
   {
      key = 'c',
      mods = 'CTRL|ALT',
      action = profiles.spawn_profile_action('claude'),
   },
   {
      key = 'g',
      mods = 'CTRL|ALT',
      action = profiles.spawn_profile_action('gemini'),
   },
   {
      key = 'r',
      mods = 'CTRL|ALT',
      action = profiles.spawn_profile_action('grok'),
   },
   {
      key = 'x',
      mods = 'CTRL|ALT',
      action = profiles.spawn_profile_action('codex'),
   },
}

-- stylua: ignore
local key_tables = {
   resize_font = {
      { key = 'k',      action = act.IncreaseFontSize },
      { key = 'j',      action = act.DecreaseFontSize },
      { key = 'r',      action = act.ResetFontSize },
      { key = 'Escape', action = 'PopKeyTable' },
      { key = 'q',      action = 'PopKeyTable' },
   },
}

local mouse_bindings = {
   -- Ctrl-click will open the link under the mouse cursor
   {
      event = { Up = { streak = 1, button = 'Left' } },
      mods = 'CTRL',
      action = act.OpenLinkAtMouseCursor,
   },
}

return {
   disable_default_key_bindings = true,
   -- disable_default_mouse_bindings = true,
   leader = { key = 'Space', mods = mod.SUPER_REV },
   keys = keys,
   key_tables = key_tables,
   mouse_bindings = mouse_bindings,
}

===== config/domains.lua =====
local platform = require('utils.platform')

local options = {
   -- ref: https://wezfurlong.org/wezterm/config/lua/SshDomain.html
   ssh_domains = {},

   -- ref: https://wezfurlong.org/wezterm/multiplexing.html#unix-domains
   unix_domains = {},

   -- ref: https://wezfurlong.org/wezterm/config/lua/WslDomain.html
   wsl_domains = {},
}

if platform.is_win then
   options.wsl_domains = {
      {
         name = 'WSL:Ubuntu',
         distribution = 'Ubuntu',
         username = 'will_schaefer',
         default_cwd = '/home/will_schaefer',
         default_prog = { 'fish', '-l' },
      },
   }
end

return options

===== config/fonts.lua =====
local wezterm = require('wezterm')
local platform = require('utils.platform')

-- Matching Windows Terminal font
local font_family = 'CodeNewRoman Nerd Font Mono'
-- Alternatives:
-- local font_family = 'iMWritingMono Nerd Font Mono'
-- local font_family = 'Maple Mono NF'
-- local font_family = 'Hack Nerd Font Mono'

local font_size = 15  -- Matching Windows Terminal

return {
   font = wezterm.font({
      family = font_family,
      weight = 347,  -- Matching Windows Terminal weight
   }),
   font_size = font_size,
   line_height = 1.2, -- Matching cellHeight: 1.2

   --ref: https://wezfurlong.org/wezterm/config/lua/config/freetype_pcf_long_family_names.html#why-doesnt-wezterm-use-the-distro-freetype-or-match-its-configuration
   freetype_load_target = 'Normal', ---@type 'Normal'|'Light'|'Mono'|'HorizontalLcd'
   freetype_render_target = 'Normal', ---@type 'Normal'|'Light'|'Mono'|'HorizontalLcd'
}

===== config/general.lua =====
return {
   -- behaviours
   automatically_reload_config = true,
   exit_behavior = 'CloseOnCleanExit', -- if the shell program exited with a successful status
   exit_behavior_messaging = 'Verbose',
   status_update_interval = 1000,
   audible_bell = 'Disabled',

   scrollback_lines = 20000,

   hyperlink_rules = {
      -- Matches: a URL in parens: (URL)
      {
         regex = '\\((\\w+://\\S+)\\)',
         format = '$1',
         highlight = 1,
      },
      -- Matches: a URL in brackets: [URL]
      {
         regex = '\\[(\\w+://\\S+)\\]',
         format = '$1',
         highlight = 1,
      },
      -- Matches: a URL in curly braces: {URL}
      {
         regex = '\\{(\\w+://\\S+)\\}',
         format = '$1',
         highlight = 1,
      },
      -- Matches: a URL in angle brackets: <URL>
      {
         regex = '<(\\w+://\\S+)>',
         format = '$1',
         highlight = 1,
      },
      -- Then handle URLs not wrapped in brackets
      {
         regex = '\\b\\w+://\\S+[)/a-zA-Z0-9-]+',
         format = '$0',
      },
      -- implicit mailto link
      {
         regex = '\\b\\w+@[\\w-]+(\\.[\\w-]+)+\\b',
         format = 'mailto:$0',
      },
   },
}

===== config/init.lua =====
local wezterm = require('wezterm')

---@class Config
---@field options table
local Config = {}
Config.__index = Config

---Initialize Config
---@return Config
function Config:init()
   local config = setmetatable({ options = {} }, self)
   return config
end

---Append to `Config.options`
---@param new_options table new options to append
---@return Config
function Config:append(new_options)
   for k, v in pairs(new_options) do
      if self.options[k] ~= nil then
         wezterm.log_warn(
            'Duplicate config option detected: ',
            { old = self.options[k], new = new_options[k] }
         )
         goto continue
      end
      self.options[k] = v
      ::continue::
   end
   return self
end

return Config

===== config/launch.lua =====
local platform = require('utils.platform')

local options = {
   default_prog = {},
   launch_menu = {},
}

if platform.is_win then
   -- Default to Ubuntu WSL with Fish shell
   options.default_prog = { 'wsl.exe', '-d', 'Ubuntu', '--cd', '~', '-e', 'fish' }
   options.launch_menu = {
      { label = 'Ubuntu (Fish)', args = { 'wsl.exe', '-d', 'Ubuntu', '--cd', '~', '-e', 'fish' } },
      { label = 'Ubuntu (Bash)', args = { 'wsl.exe', '-d', 'Ubuntu', '--cd', '~' } },
      { label = 'PowerShell Core', args = { 'pwsh', '-NoLogo' } },
      { label = 'PowerShell Desktop', args = { 'powershell' } },
      { label = 'Command Prompt', args = { 'cmd' } },
   }
elseif platform.is_mac then
   options.default_prog = { 'zsh', '-l' }
   options.launch_menu = {
      { label = 'Zsh', args = { 'zsh', '-l' } },
      { label = 'Bash', args = { 'bash', '-l' } },
   }
elseif platform.is_linux then
   options.default_prog = { 'tmux' }
   options.launch_menu = {
      { label = 'Bash', args = { 'bash', '-l' } },
      { label = 'Fish', args = { 'fish', '-l' } },
      { label = 'Zsh', args = { 'zsh', '-l' } },
   }
end

return options

===== config/profiles.lua =====
-- CLI Profile Definitions for AI Tools
-- Each profile has unique colors, fonts, and window settings

local wezterm = require('wezterm')
local platform = require('utils.platform')

local M = {}

-- Get home directory in a cross-platform way
local home = wezterm.home_dir

-- Define execution domains
local wsl_domain = nil
if platform.is_win then
   wsl_domain = { DomainName = 'WSL:Ubuntu' }
end

-- Profile definitions for each AI CLI
M.profiles = {
   claude = {
      name = 'Claude',
      color_scheme = 'Claude',
      font = 'Hurmit Nerd Font',
      window_title = 'Claude',
      -- Use 'claude' and rely on shell PATH, running in WSL domain on Windows
      cli_command = { 'claude' },
      domain = wsl_domain,
      env = { CLI_PROFILE = 'claude' },
      cursor_color = '#C15F3C',
   },
   gemini = {
      name = 'Gemini',
      color_scheme = 'Gemini',
      font = 'EnvyCodeR Nerd Font',
      window_title = 'Gemini',
      cli_command = { 'gemini' },
      domain = wsl_domain,
      env = { CLI_PROFILE = 'gemini' },
      cursor_color = '#4285F4',
   },
   grok = {
      name = 'Grok',
      color_scheme = 'Grok',
      font = 'CaskaydiaCove Nerd Font',
      window_title = 'Grok',
      cli_command = { 'grok' },
      domain = wsl_domain,
      env = { CLI_PROFILE = 'grok' },
      cursor_color = '#FF007F',
   },
   codex = {
      name = 'Codex',
      color_scheme = 'Codex',
      font = 'SpaceMono Nerd Font',
      window_title = 'Codex',
      cli_command = { 'codex' },
      domain = wsl_domain,
      env = { CLI_PROFILE = 'codex' },
      cursor_color = '#9B7CD5',
   },
}

-- Create a SpawnCommand for a profile
function M.spawn_command(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      wezterm.log_error('Unknown profile: ' .. tostring(profile_name))
      return nil
   end

   return {
      args = profile.cli_command,
      set_environment_variables = profile.env,
      domain = profile.domain,
   }
end

-- Get profile-specific window configuration
function M.get_window_config(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      return {}
   end

   return {
      color_scheme = profile.color_scheme,
      font = wezterm.font(profile.font),
      window_frame = {
         font = wezterm.font(profile.font),
      },
   }
end

-- Action to spawn a new window with a specific profile
function M.spawn_profile_action(profile_name)
   local profile = M.profiles[profile_name]
   if not profile then
      return wezterm.action.Nop
   end

   return wezterm.action_callback(function(window, pane)
      local spawn_cmd = M.spawn_command(profile_name)
      if spawn_cmd then
         -- Spawn in a new window with profile-specific settings
         wezterm.mux.spawn_window({
            args = spawn_cmd.args,
            set_environment_variables = spawn_cmd.set_environment_variables,
            domain = spawn_cmd.domain,
            cwd = pane:get_current_working_dir(),
         })
      end
   end)
end

return M

===== config/starlight.lua =====
local wezterm = require('wezterm')
local colors = require('colors.custom')

local nf = wezterm.nerdfonts

local M = {}

M.palette = {
   bg = colors.background,
   fg = colors.foreground,
   accent = (colors.brights and colors.brights[6]) or colors.foreground,
   dim = (colors.ansi and colors.ansi[1]) or colors.foreground,
}

M.icons = {
   home = nf.md_home or nf.fa_home,
   root = nf.md_folder_root or nf.fa_folder_open,
   folder = nf.md_folder or nf.fa_folder,
   unknown = nf.md_map_marker or nf.fa_map_marker,
   starlight = nf.md_star_four_points or nf.fa_star,
}

local function decode_uri_path(path)
   if not path then
      return nil
   end
   return path:gsub('%%(%x%x)', function(hex)
      return string.char(tonumber(hex, 16))
   end)
end

local function strip_trailing_slashes(path)
   if path == '/' then
      return path
   end
   return path:gsub('/+$', '')
end

local function normalize_path(path)
   if not path then
      return nil
   end
   local normalized = tostring(path)
   normalized = normalized:gsub('^file://', '')
   normalized = decode_uri_path(normalized)
   normalized = normalized:gsub('\\', '/')
   if normalized:match('^/[A-Za-z]:') then
      normalized = normalized:sub(2)
   end
   normalized = strip_trailing_slashes(normalized)
   return normalized
end

function M.location_icon(cwd_uri)
   local cwd = normalize_path(cwd_uri)
   if not cwd or cwd == '' then
      return M.icons.unknown
   end

   local home = normalize_path(wezterm.home_dir)
   if cwd == '/' then
      return M.icons.root
   end
   if home then
      local cwd_cmp = cwd
      local home_cmp = home
      if cwd_cmp:match('^%a:') or home_cmp:match('^%a:') then
         cwd_cmp = cwd_cmp:lower()
         home_cmp = home_cmp:lower()
      end
      if cwd_cmp == home_cmp then
         return M.icons.home
      end
   end
   if cwd:match('[/\\]home[/\\][^/\\]+$') then
      return M.icons.home
   end

   return M.icons.folder
end

function M.prompt_for_pane(pane)
   local cwd_uri = pane and pane:get_current_working_dir() or nil
   local icon = M.location_icon(cwd_uri)
   local formatted = wezterm.format({
      { Foreground = { Color = M.palette.accent } },
      { Attribute = { Intensity = 'Bold' } },
      { Text = icon },
   })

   return {
      icon = icon,
      formatted = formatted,
   }
end

return M

===== events/gui-startup.lua =====
local wezterm = require('wezterm')
local mux = wezterm.mux

local M = {}

M.setup = function()
   wezterm.on('gui-startup', function(cmd)
      local _, _, window = mux.spawn_window(cmd or {})
      -- window:gui_window():maximize()
   end)
end

return M

===== events/left-status.lua =====
local wezterm = require('wezterm')
local Cells = require('utils.cells')

local nf = wezterm.nerdfonts
local attr = Cells.attr

local M = {}

local GLYPH_SEMI_CIRCLE_LEFT = nf.ple_left_half_circle_thick --[[ 'ÓÇ∂' ]]
local GLYPH_SEMI_CIRCLE_RIGHT = nf.ple_right_half_circle_thick --[[ 'ÓÇ¥' ]]
local GLYPH_KEY_TABLE = nf.md_table_key --[[ 'Û±èÖ' ]]
local GLYPH_KEY = nf.md_key --[[ 'Û∞åÜ' ]]

---@type table<string, Cells.SegmentColors>
local colors = {
   default = { bg = '#fab387', fg = '#1c1b19' },
   scircle = { bg = 'rgba(0, 0, 0, 0.4)', fg = '#fab387' },
}

local cells = Cells:new()

cells
   :add_segment(1, GLYPH_SEMI_CIRCLE_LEFT, colors.scircle, attr(attr.intensity('Bold')))
   :add_segment(2, ' ', colors.default, attr(attr.intensity('Bold')))
   :add_segment(3, ' ', colors.default, attr(attr.intensity('Bold')))
   :add_segment(4, GLYPH_SEMI_CIRCLE_RIGHT, colors.scircle, attr(attr.intensity('Bold')))

M.setup = function()
   wezterm.on('update-right-status', function(window, _pane)
      local name = window:active_key_table()
      local res = {}

      if name then
         cells
            :update_segment_text(2, GLYPH_KEY_TABLE)
            :update_segment_text(3, ' ' .. string.upper(name))
         res = cells:render_all()
      end

      if window:leader_is_active() then
         cells:update_segment_text(2, GLYPH_KEY):update_segment_text(3, ' ')
         res = cells:render_all()
      end
      window:set_left_status(wezterm.format(res))
   end)
end

return M

===== events/new-tab-button.lua =====
local wezterm = require('wezterm')
local launch_menu = require('config.launch').launch_menu
local domains = require('config.domains')
local Cells = require('utils.cells')
local starlight = require('config.starlight')

local nf = wezterm.nerdfonts
local act = wezterm.action
local attr = Cells.attr

local M = {}

---@type table<string, Cells.SegmentColors>
-- stylua: ignore
local colors = {
   label_text   = { fg = '#CDD6F4' },
   icon_default = { fg = '#89B4FA' },
   icon_wsl     = { fg = '#FAB387' },
   icon_ssh     = { fg = '#F38BA8' },
   icon_unix    = { fg = '#CBA6F7' },
}

local cells = Cells:new()
   :add_segment('icon_default', ' ' .. nf.oct_terminal .. ' ', colors.icon_default)
   :add_segment('icon_wsl', ' ' .. nf.cod_terminal_linux .. ' ', colors.icon_wsl)
   :add_segment('icon_ssh', ' ' .. nf.md_ssh .. ' ', colors.icon_ssh)
   :add_segment('icon_unix', ' ' .. nf.dev_gnu .. ' ', colors.icon_unix)
   :add_segment('label_text', '', colors.label_text, attr(attr.intensity('Bold')))

local function build_choices()
   local choices = {}
   local choices_data = {}
   local idx = 1

   -- Add launch menu items (DefaultDomain)
   for _, v in ipairs(launch_menu) do
      cells:update_segment_text('label_text', v.label)

      table.insert(choices, {
         id = tostring(idx),
         label = wezterm.format(cells:render({ 'icon_default', 'label_text' })),
      })
      table.insert(choices_data, {
         args = v.args,
         domain = 'DefaultDomain',
      })
      idx = idx + 1
   end

   -- Add WSL domains
   for _, v in ipairs(domains.wsl_domains) do
      cells:update_segment_text('label_text', v.name)

      table.insert(choices, {
         id = tostring(idx),
         label = wezterm.format(cells:render({ 'icon_wsl', 'label_text' })),
      })
      table.insert(choices_data, {
         domain = { DomainName = v.name },
      })
      idx = idx + 1
   end

   -- Add SSH domains
   for _, v in ipairs(domains.ssh_domains) do
      cells:update_segment_text('label_text', v.name)
      table.insert(choices, {
         id = tostring(idx),
         label = wezterm.format(cells:render({ 'icon_ssh', 'label_text' })),
      })
      table.insert(choices_data, {
         domain = { DomainName = v.name },
      })
      idx = idx + 1
   end

   -- Add Unix domains
   for _, v in ipairs(domains.unix_domains) do
      cells:update_segment_text('label_text', v.name)
      table.insert(choices, {
         id = tostring(idx),
         label = wezterm.format(cells:render({ 'icon_unix', 'label_text' })),
      })
      table.insert(choices_data, {
         domain = { DomainName = v.name },
      })
      idx = idx + 1
   end

   return choices, choices_data
end

local choices, choices_data = build_choices()

M.setup = function()
   wezterm.on('new-tab-button-click', function(window, pane, button, default_action)
      if default_action and button == 'Left' then
         window:perform_action(default_action, pane)
      end

      if default_action and button == 'Right' then
         local prompt = starlight.prompt_for_pane(pane)
         window:perform_action(
            act.InputSelector({
               title = prompt.icon,
               choices = choices,
               fuzzy = true,
               fuzzy_description = prompt.icon,
               action = wezterm.action_callback(function(_window, _pane, id, label)
                  if not id and not label then
                     return
                  else
                     wezterm.log_info('you selected ', id, label)
                     wezterm.log_info(choices_data[tonumber(id)])
                     window:perform_action(
                        act.SpawnCommandInNewTab(choices_data[tonumber(id)]),
                        pane
                     )
                  end
               end),
            }),
            pane
         )
      end
      return false
   end)
end

return M

===== events/right-status.lua =====
local wezterm = require('wezterm')
local umath = require('utils.math')
local Cells = require('utils.cells')
local OptsValidator = require('utils.opts-validator')

---@alias Event.RightStatusOptions { date_format?: string }

---Setup options for the right status bar
local EVENT_OPTS = {}

---@type OptsSchema
EVENT_OPTS.schema = {
   {
      name = 'date_format',
      type = 'string',
      default = '%a %H:%M:%S',
   },
}
EVENT_OPTS.validator = OptsValidator:new(EVENT_OPTS.schema)

local nf = wezterm.nerdfonts
local attr = Cells.attr

local M = {}

local ICON_SEPARATOR = nf.oct_dash
local ICON_DATE = nf.fa_calendar

---@type string[]
local discharging_icons = {
   nf.md_battery_10,
   nf.md_battery_20,
   nf.md_battery_30,
   nf.md_battery_40,
   nf.md_battery_50,
   nf.md_battery_60,
   nf.md_battery_70,
   nf.md_battery_80,
   nf.md_battery_90,
   nf.md_battery,
}
---@type string[]
local charging_icons = {
   nf.md_battery_charging_10,
   nf.md_battery_charging_20,
   nf.md_battery_charging_30,
   nf.md_battery_charging_40,
   nf.md_battery_charging_50,
   nf.md_battery_charging_60,
   nf.md_battery_charging_70,
   nf.md_battery_charging_80,
   nf.md_battery_charging_90,
   nf.md_battery_charging,
}

---@type table<string, Cells.SegmentColors>
-- stylua: ignore
local colors = {
   date      = { fg = '#fab387', bg = 'rgba(0, 0, 0, 0.4)' },
   battery   = { fg = '#f9e2af', bg = 'rgba(0, 0, 0, 0.4)' },
   separator = { fg = '#74c7ec', bg = 'rgba(0, 0, 0, 0.4)' }
}

local cells = Cells:new()

cells
   :add_segment('date_icon', ICON_DATE .. '  ', colors.date, attr(attr.intensity('Bold')))
   :add_segment('date_text', '', colors.date, attr(attr.intensity('Bold')))
   :add_segment('separator', ' ' .. ICON_SEPARATOR .. '  ', colors.separator)
   :add_segment('battery_icon', '', colors.battery)
   :add_segment('battery_text', '', colors.battery, attr(attr.intensity('Bold')))

---@return string, string
local function battery_info()
   -- ref: https://wezfurlong.org/wezterm/config/lua/wezterm/battery_info.html

   local charge = ''
   local icon = ''

   for _, b in ipairs(wezterm.battery_info()) do
      local idx = umath.clamp(umath.round(b.state_of_charge * 10), 1, 10)
      charge = string.format('%.0f%%', b.state_of_charge * 100)

      if b.state == 'Charging' then
         icon = charging_icons[idx]
      else
         icon = discharging_icons[idx]
      end
   end

   return charge, icon .. ' '
end

---@param opts? Event.RightStatusOptions Default: {date_format = '%a %H:%M:%S'}
M.setup = function(opts)
   local valid_opts, err = EVENT_OPTS.validator:validate(opts or {})

   if err then
      wezterm.log_error(err)
   end

   wezterm.on('update-right-status', function(window, _pane)
      local battery_text, battery_icon = battery_info()

      cells
         :update_segment_text('date_text', wezterm.strftime(valid_opts.date_format))
         :update_segment_text('battery_icon', battery_icon)
         :update_segment_text('battery_text', battery_text)

      window:set_right_status(
         wezterm.format(
            cells:render({ 'date_icon', 'date_text', 'separator', 'battery_icon', 'battery_text' })
         )
      )
   end)
end

return M

===== events/tab-title.lua =====
------------------------------------------------------------------------------------------
-- Inspired by https://github.com/wez/wezterm/discussions/628#discussioncomment-1874614 --
------------------------------------------------------------------------------------------

local wezterm = require('wezterm')
local Cells = require('utils.cells')
local OptsValidator = require('utils.opts-validator')
local starlight = require('config.starlight')

---
-- =======================================
-- Defining event setup options and schema
-- =======================================

---@alias Event.TabTitleOptions { unseen_icon: 'circle' | 'numbered_circle' | 'numbered_box', hide_active_tab_unseen: boolean }

---Setup options for the tab title
local EVENT_OPTS = {}

---@type OptsSchema
EVENT_OPTS.schema = {
   {
      name = 'unseen_icon',
      type = 'string',
      enum = { 'circle', 'numbered_circle', 'numbered_box' },
      default = 'circle',
   },
   {
      name = 'hide_active_tab_unseen',
      type = 'boolean',
      default = true,
   },
}
EVENT_OPTS.validator = OptsValidator:new(EVENT_OPTS.schema)

---
-- ===================
-- Constants and icons
-- ===================

local nf = wezterm.nerdfonts

local M = {}

local GLYPH_SCIRCLE_LEFT = nf.ple_left_half_circle_thick --[[ ÓÇ∂ ]]
local GLYPH_SCIRCLE_RIGHT = nf.ple_right_half_circle_thick --[[ ÓÇ¥ ]]
local GLYPH_CIRCLE = nf.fa_circle --[[ ÔÑë ]]
local GLYPH_ADMIN = nf.md_shield_half_full --[[ Û∞ûÄ ]]
local GLYPH_LINUX = nf.cod_terminal_linux --[[ ÓØÜ ]]
local GLYPH_DEBUG = nf.fa_bug --[[ Ó´ò ]]
-- local GLYPH_SEARCH = nf.fa_search --[[ ÔÄÇ ]]
local GLYPH_SEARCH = 'üî≠'

local GLYPH_UNSEEN_NUMBERED_BOX = {
   [1] = nf.md_numeric_1_box_multiple, --[[ Û∞ºè ]]
   [2] = nf.md_numeric_2_box_multiple, --[[ Û∞ºê ]]
   [3] = nf.md_numeric_3_box_multiple, --[[ Û∞ºë ]]
   [4] = nf.md_numeric_4_box_multiple, --[[ Û∞ºí ]]
   [5] = nf.md_numeric_5_box_multiple, --[[ Û∞ºì ]]
   [6] = nf.md_numeric_6_box_multiple, --[[ Û∞ºî ]]
   [7] = nf.md_numeric_7_box_multiple, --[[ Û∞ºï ]]
   [8] = nf.md_numeric_8_box_multiple, --[[ Û∞ºñ ]]
   [9] = nf.md_numeric_9_box_multiple, --[[ Û∞ºó ]]
   [10] = nf.md_numeric_9_plus_box_multiple, --[[ Û∞ºò ]]
}

local GLYPH_UNSEEN_NUMBERED_CIRCLE = {
   [1] = nf.md_numeric_1_circle, --[[ Û∞≤† ]]
   [2] = nf.md_numeric_2_circle, --[[ Û∞≤¢ ]]
   [3] = nf.md_numeric_3_circle, --[[ Û∞≤§ ]]
   [4] = nf.md_numeric_4_circle, --[[ Û∞≤¶ ]]
   [5] = nf.md_numeric_5_circle, --[[ Û∞≤® ]]
   [6] = nf.md_numeric_6_circle, --[[ Û∞≤™ ]]
   [7] = nf.md_numeric_7_circle, --[[ Û∞≤¨ ]]
   [8] = nf.md_numeric_8_circle, --[[ Û∞≤Æ ]]
   [9] = nf.md_numeric_9_circle, --[[ Û∞≤∞ ]]
   [10] = nf.md_numeric_9_plus_circle, --[[ Û∞≤≤ ]]
}

local TITLE_INSET = {
   DEFAULT = 6,
   ICON = 8,
}

local RENDER_VARIANTS = {
   { 'scircle_left', 'title', 'padding', 'scircle_right' },
   { 'scircle_left', 'title', 'unseen_output', 'padding', 'scircle_right' },
   { 'scircle_left', 'admin', 'title', 'padding', 'scircle_right' },
   { 'scircle_left', 'admin', 'title', 'unseen_output', 'padding', 'scircle_right' },
   { 'scircle_left', 'wsl', 'title', 'padding', 'scircle_right' },
   { 'scircle_left', 'wsl', 'title', 'unseen_output', 'padding', 'scircle_right' },
}


local colors_custom = require('colors.custom')

local nord = {
   base      = '#2e3440',
   mantle    = '#242933',
   surface0  = '#3b4252',
   surface1  = '#434c5e',
   surface2  = '#4c566a',
   text      = '#e5e9f0',
   subtext0  = '#d8dee9',
   
   -- Muted High Contrast Palette
   purple    = '#b48ead',
   teal      = '#8fbcbb',
   pink      = '#ff92df', -- Custom bright pink/flamingo
   green     = '#a3be8c', -- Muted green
   blue      = '#81a1c1',
   yellow    = '#ebcb8b',
   peach     = '#d08770',
}

local rainbow = {
   nord.purple,
   nord.teal,
   nord.pink,
   nord.green,
   nord.blue,
   nord.yellow,
   nord.peach,
}

---@type table<string, Cells.SegmentColors>
-- stylua: ignore
local colors = {
   -- Base defaults (will be overridden dynamically)
   text_default          = { bg = nord.surface0, fg = nord.subtext0 },
   text_hover            = { bg = nord.surface1, fg = nord.text },
   text_active           = { bg = nord.purple,   fg = nord.base },

   unseen_output_default = { bg = nord.surface0, fg = nord.gold },
   unseen_output_hover   = { bg = nord.surface1, fg = nord.gold },
   unseen_output_active  = { bg = nord.purple,   fg = nord.base },

   scircle_default       = { bg = nord.mantle,   fg = nord.surface0 },
   scircle_hover         = { bg = nord.mantle,   fg = nord.surface1 },
   scircle_active        = { bg = nord.mantle,   fg = nord.purple },
}

---
-- ================
-- Helper functions
-- ================

---@param proc string
local function clean_process_name(proc)
   local a = string.gsub(proc, '(.*[/\\])(.*)', '%2')
   return a:gsub('%.exe$', '')
end

---@param process_name string
---@param base_title string
---@param max_width number
---@param inset number
local function create_title(process_name, base_title, max_width, inset)
   local title

   if process_name:len() > 0 then
      title = process_name .. ' ~ ' .. base_title
   else
      title = base_title
   end

   if base_title == 'Debug' then
      title = GLYPH_DEBUG .. ' DEBUG'
      inset = inset - 2
   end

   if base_title:match('^InputSelector:') ~= nil then
      title = base_title:gsub('InputSelector:', GLYPH_SEARCH)
      inset = inset - 2
   end

   if title:len() > max_width - inset then
      local diff = title:len() - max_width + inset
      title = title:sub(1, title:len() - diff)
   else
      local padding = max_width - title:len() - inset
      title = title .. string.rep(' ', padding)
   end

   return title
end

---@param panes any[] WezTerm https://wezfurlong.org/wezterm/config/lua/pane/index.html
local function check_unseen_output(panes)
   local unseen_output = false
   local unseen_output_count = 0

   for i = 1, #panes, 1 do
      if panes[i].has_unseen_output then
         unseen_output = true
         if unseen_output_count >= 10 then
            unseen_output_count = 10
            break
         end
         unseen_output_count = unseen_output_count + 1
      end
   end

   return unseen_output, unseen_output_count
end

---
-- =================
-- Tab class and API
-- =================

---@class Tab
---@field title string
---@field cells FormatCells
---@field title_locked boolean
---@field locked_title string
---@field is_wsl boolean
---@field is_admin boolean
---@field unseen_output boolean
---@field unseen_output_count number
---@field is_active boolean
local Tab = {}
Tab.__index = Tab

function Tab:new()
   local tab = {
      title = '',
      cells = Cells:new(),
      title_locked = false,
      locked_title = '',
      is_wsl = false,
      is_admin = false,
      unseen_output = false,
      unseen_output_count = 0,
   }
   return setmetatable(tab, self)
end

---@param event_opts Event.TabTitleOptions
---@param tab any WezTerm https://wezfurlong.org/wezterm/config/lua/MuxTab/index.html
---@param max_width number
function Tab:set_info(event_opts, tab, max_width)
   local process_name = clean_process_name(tab.active_pane.foreground_process_name)

   self.is_wsl = process_name:match('^wsl') ~= nil
   self.is_admin = (
      tab.active_pane.title:match('^Administrator: ') or tab.active_pane.title:match('(Admin)')
   ) ~= nil
   self.unseen_output = false
   self.unseen_output_count = 0

   if not event_opts.hide_active_tab_unseen or not tab.is_active then
      self.unseen_output, self.unseen_output_count = check_unseen_output(tab.panes)
   end

   local inset = (self.is_admin or self.is_wsl) and TITLE_INSET.ICON or TITLE_INSET.DEFAULT
   if self.unseen_output then
      inset = inset + 2
   end

   if self.title_locked then
      self.title = create_title('', self.locked_title, max_width, inset)
      return
   end
   self.title = create_title(process_name, tab.active_pane.title, max_width, inset)
end

function Tab:create_cells()
   local attr = self.cells.attr
   self.cells
      :add_segment('scircle_left', GLYPH_SCIRCLE_LEFT)
      :add_segment('admin', ' ' .. GLYPH_ADMIN)
      :add_segment('wsl', ' ' .. GLYPH_LINUX)
      :add_segment('title', ' ', nil, attr(attr.intensity('Bold')))
      :add_segment('unseen_output', ' ' .. GLYPH_CIRCLE)
      :add_segment('padding', ' ')
      :add_segment('scircle_right', GLYPH_SCIRCLE_RIGHT)
end

---@param title string
function Tab:update_and_lock_title(title)
   self.locked_title = title
   self.title_locked = true
end

---@param event_opts Event.TabTitleOptions
---@param is_active boolean
---@param hover boolean
---@param tab_index number
function Tab:update_cells(event_opts, is_active, hover, tab_index)
   -- Determine specific color for this tab index
   local specific_color = rainbow[(tab_index % #rainbow) + 1]

   local fg_color = nord.text
   local bg_color = nord.surface0
   local scircle_bg = nord.mantle
   local scircle_fg = nord.surface0

   if is_active then
      bg_color = specific_color
      fg_color = nord.base
      scircle_fg = specific_color
   elseif hover then
      bg_color = nord.surface1
      fg_color = specific_color -- Hint at color on hover
      scircle_fg = nord.surface1
   else
      -- Inactive: Dark bg, but text is colored to match the tab's identity
      bg_color = nord.surface0
      fg_color = specific_color
      scircle_fg = nord.surface0
   end

   self.cells:update_segment_text('title', ' ' .. self.title)

   if event_opts.unseen_icon == 'numbered_box' and self.unseen_output then
      self.cells:update_segment_text(
         'unseen_output',
         ' ' .. GLYPH_UNSEEN_NUMBERED_BOX[self.unseen_output_count]
      )
   end
   if event_opts.unseen_icon == 'numbered_circle' and self.unseen_output then
      self.cells:update_segment_text(
         'unseen_output',
         ' ' .. GLYPH_UNSEEN_NUMBERED_CIRCLE[self.unseen_output_count]
      )
   end

   -- Apply dynamic colors
   local text_colors = { bg = bg_color, fg = fg_color }
   local scircle_left_colors = { bg = scircle_bg, fg = scircle_fg }
   local scircle_right_colors = { bg = scircle_bg, fg = scircle_fg }
   local unseen_colors = { bg = bg_color, fg = nord.gold }
   
   -- Special override for active unread (keep high contrast)
   if is_active then
       unseen_colors.fg = nord.base
   end

   self.cells
      :update_segment_colors('scircle_left', scircle_left_colors)
      :update_segment_colors('admin', text_colors)
      :update_segment_colors('wsl', text_colors)
      :update_segment_colors('title', text_colors)
      :update_segment_colors('unseen_output', unseen_colors)
      :update_segment_colors('padding', text_colors)
      :update_segment_colors('scircle_right', scircle_right_colors)
end

---@return FormatItem[] (ref: https://wezfurlong.org/wezterm/config/lua/wezterm/format.html)
function Tab:render()
   local variant_idx = self.is_admin and 3 or 1
   if self.is_wsl then
      variant_idx = 5
   end

   if self.unseen_output then
      variant_idx = variant_idx + 1
   end
   return self.cells:render(RENDER_VARIANTS[variant_idx])
end

---@type Tab[]
local tab_list = {}

---@param opts? Event.TabTitleOptions Default: {unseen_icon = 'circle', hide_active_tab_unseen = true}
M.setup = function(opts)
   local valid_opts, err = EVENT_OPTS.validator:validate(opts or {})

   if err then
      wezterm.log_error(err)
   end

   -- CUSTOM EVENT
   -- Event listener to manually update the tab name
   -- Tab name will remain locked until the `reset-tab-title` is triggered
   wezterm.on('tabs.manual-update-tab-title', function(window, pane)
      window:perform_action(
         wezterm.action.PromptInputLine({
            description = starlight.prompt_for_pane(pane).formatted,
            action = wezterm.action_callback(function(_window, _pane, line)
               if line ~= nil then
                  local tab = window:active_tab()
                  local id = tab:tab_id()
                  tab_list[id]:update_and_lock_title(line)
               end
            end),
         }),
         pane
      )
   end)

   -- CUSTOM EVENT
   -- Event listener to unlock manually set tab name
   wezterm.on('tabs.reset-tab-title', function(window, _pane)
      local tab = window:active_tab()
      local id = tab:tab_id()
      tab_list[id].title_locked = false
   end)

   -- CUSTOM EVENT
   -- Event listener to manually update the tab name
   wezterm.on('tabs.toggle-tab-bar', function(window, _pane)
      local effective_config = window:effective_config()
      window:set_config_overrides({
         enable_tab_bar = not effective_config.enable_tab_bar,
         background = effective_config.background,
      })
   end)

   -- BUILTIN EVENT
   wezterm.on('format-tab-title', function(tab, _tabs, _panes, _config, hover, max_width)
      if not tab_list[tab.tab_id] then
         tab_list[tab.tab_id] = Tab:new()
         tab_list[tab.tab_id]:set_info(valid_opts, tab, max_width)
         tab_list[tab.tab_id]:create_cells()
         -- Pass tab_index to update_cells
         tab_list[tab.tab_id]:update_cells(valid_opts, tab.is_active, hover, tab.tab_index)
         return tab_list[tab.tab_id]:render()
      end

      tab_list[tab.tab_id]:set_info(valid_opts, tab, max_width)
      -- Pass tab_index to update_cells
      tab_list[tab.tab_id]:update_cells(valid_opts, tab.is_active, hover, tab.tab_index)
      return tab_list[tab.tab_id]:render()
   end)
end

return M

===== inspo/COLOR_SCHEMES_THEMES.md =====
# WezTerm Color Schemes & Themes Inspiration

## Downloaded Screenshots (in this folder)
- `catppuccin-wezterm-screenshot.webp` - Official Catppuccin theme (331‚≠ê)

## Popular Color Themes for WezTerm

### 1. Catppuccin (331‚≠ê) ‚≠ê MOST POPULAR
**URL**: https://github.com/catppuccin/wezterm
**Built into WezTerm**: Yes! 
**Flavors**: 
- Mocha (dark)
- Macchiato (dark) 
- Frappe (dark)
- Latte (light)

**Usage**:
```lua
config.color_scheme = "Catppuccin Mocha"  -- or Macchiato, Frappe, Latte
```

**Auto Dark/Light Mode**:
```lua
local wezterm = require "wezterm"

function scheme_for_appearance(appearance)
  if appearance:find "Dark" then
    return "Catppuccin Mocha"
  else
    return "Catppuccin Latte"
  end
end

config.color_scheme = scheme_for_appearance(wezterm.gui.get_appearance())
```

**Custom Overrides**:
```lua
local custom = wezterm.color.get_builtin_schemes()["Catppuccin Mocha"]
custom.background = "#000000"
custom.tab_bar.background = "#040404"
config.color_schemes = { ["OLEDppuccin"] = custom }
config.color_scheme = "OLEDppuccin"
```

### 2. Tokyo Night
**Built into WezTerm**: Yes
**Variants**: 
- Tokyo Night
- Tokyo Night Storm
- Tokyo Night Moon

**Usage**:
```lua
config.color_scheme = "Tokyo Night"
```

### 3. Nord
**Built into WezTerm**: Yes
**Usage**:
```lua
config.color_scheme = "Nord"
```

### 4. Gruvbox
**Built into WezTerm**: Yes (multiple variants)
**Variants**:
- Gruvbox Dark
- Gruvbox Light
- Gruvbox Material

**Usage**:
```lua
config.color_scheme = "Gruvbox Dark"
```

### 5. Poimandres (492‚≠ê)
**URL**: https://github.com/olivercederborg/poimandres.nvim
**Built into WezTerm**: Yes
**Features**: Supports WezTerm, Neovim, Kitty, Alacritty

**Usage**:
```lua
config.color_scheme = "Poimandres"
```

### 6. Dracula
**Built into WezTerm**: Yes
**Usage**:
```lua
config.color_scheme = "Dracula"
```

### 7. One Dark
**Built into WezTerm**: Yes
**Usage**:
```lua
config.color_scheme = "One Dark (Gogh)"
```

### 8. Solarized
**Built into WezTerm**: Yes
**Variants**: Light and Dark
**Usage**:
```lua
config.color_scheme = "Solarized Dark"
-- or
config.color_scheme = "Solarized Light"
```

## All Built-in WezTerm Color Schemes

WezTerm includes 500+ color schemes! Browse them at:
https://wezfurlong.org/wezterm/colorschemes/index.html

### Popular Categories:
- **Dark**: Mocha, Tokyo Night, Nord, Dracula, OneDark
- **Light**: Catppuccin Latte, Solarized Light, GitHub Light
- **Pastel**: Catppuccin, Ros√© Pine
- **High Contrast**: Gruvbox, Monokai

## Creating Custom Color Schemes

### Method 1: Override Built-in Scheme
```lua
local wezterm = require 'wezterm'
local custom = wezterm.color.get_builtin_schemes()["Catppuccin Mocha"]

-- Customize colors
custom.background = "#1a1b26"
custom.foreground = "#c0caf5"
custom.cursor_bg = "#c0caf5"
custom.cursor_border = "#c0caf5"
custom.selection_bg = "#33467c"
custom.selection_fg = "#c0caf5"

-- Tab bar colors
custom.tab_bar.background = "#1a1b26"
custom.tab_bar.active_tab.bg_color = "#7aa2f7"
custom.tab_bar.active_tab.fg_color = "#1a1b26"

return {
  color_schemes = {
    ["MyCustom"] = custom,
  },
  color_scheme = "MyCustom",
}
```

### Method 2: Define from Scratch
```lua
return {
  color_schemes = {
    ["MyScheme"] = {
      foreground = "#dcd7ba",
      background = "#1f1f28",
      
      cursor_bg = "#c8c093",
      cursor_fg = "#1f1f28",
      cursor_border = "#c8c093",
      
      selection_fg = "#c8c093",
      selection_bg = "#2d4f67",
      
      scrollbar_thumb = "#16161d",
      split = "#16161d",
      
      ansi = {
        "#090618", "#c34043", "#76946a", "#c0a36e",
        "#7e9cd8", "#957fb8", "#6a9589", "#c8c093",
      },
      brights = {
        "#727169", "#e82424", "#98bb6c", "#e6c384",
        "#7fb4ca", "#938aa9", "#7aa89f", "#dcd7ba",
      },
      
      tab_bar = {
        background = "#1f1f28",
        active_tab = {
          bg_color = "#7e9cd8",
          fg_color = "#1f1f28",
        },
        inactive_tab = {
          bg_color = "#2a2a37",
          fg_color = "#727169",
        },
        new_tab = {
          bg_color = "#1f1f28",
          fg_color = "#727169",
        },
      },
    },
  },
  color_scheme = "MyScheme",
}
```

## Syncing with Neovim

### bg.nvim Plugin (163‚≠ê)
**URL**: https://github.com/typicode/bg.nvim
**Features**: Auto-sync terminal background with Neovim colorscheme
**Supports**: Alacritty, Kitty, Foot, WezTerm

## Tips for Choosing a Color Scheme

1. **Eye Strain**: Warmer colors (Catppuccin Mocha, Nord) are easier on eyes
2. **Contrast**: High contrast (Gruvbox) for bright environments
3. **Consistency**: Match with your Neovim/IDE theme
4. **Time of Day**: Use auto dark/light switching
5. **Monitor Type**: OLED benefits from true black backgrounds

## Next Steps

1. ‚úÖ Downloaded Catppuccin screenshot
2. ‚è≠Ô∏è Next: Layout/pane configurations
3. ‚è≠Ô∏è Then: Background/transparency effects

## Resources
- WezTerm Color Schemes: https://wezfurlong.org/wezterm/colorschemes/index.html
- Catppuccin Ports: https://github.com/catppuccin/catppuccin
- Color Scheme Generator: https://terminal.sexy/

===== inspo/LAYOUTS_PANES_TRANSPARENCY.md =====
# WezTerm Layouts, Panes & Transparency Effects

## Background Transparency & Blur Effects

### Basic Transparency
```lua
config.window_background_opacity = 0.9  -- 0.0 (invisible) to 1.0 (opaque)
```

### macOS Blur Effect
```lua
config.window_background_opacity = 0.9
config.macos_window_background_blur = 20  -- macOS only, 0-100
```

### Acrylic Effect (Windows 11)
```lua
-- Windows 11 acrylic background
config.win32_acrylic_accent_color = "#1e1e2e"  -- Catppuccin Mocha base
config.window_background_opacity = 0.9
```

### Background Images
```lua
config.background = {
  {
    source = { File = wezterm.home_dir .. "/Pictures/wallpaper.jpg" },
    opacity = 0.8,  -- Image opacity
    hsb = {
      brightness = 0.02,  -- Darken the image
      hue = 1.0,
      saturation = 1.0,
    },
  },
}
config.window_background_opacity = 0.95  -- Overall window opacity
```

### Advanced Multi-Layer Background
```lua
config.background = {
  -- Base color layer
  {
    source = { Color = "#1e1e2e" },
    width = "100%",
    height = "100%",
  },
  -- Image layer
  {
    source = { File = wezterm.home_dir .. "/wallpaper.png" },
    opacity = 0.3,
    horizontal_align = "Center",
    vertical_align = "Middle",
  },
  -- Gradient overlay
  {
    source = {
      Gradient = {
        colors = { "#1e1e2e", "#11111b" },
        orientation = "Vertical",
      },
    },
    width = "100%",
    height = "100%",
    opacity = 0.5,
  },
}
```

## Pane Management

### Split Pane Keybindings
```lua
local config = {}

config.keys = {
  -- Split vertically (left/right)
  {
    key = '\\',
    mods = 'ALT',
    action = wezterm.action.SplitHorizontal { domain = 'CurrentPaneDomain' },
  },
  -- Split horizontally (top/bottom)
  {
    key = '-',
    mods = 'ALT',
    action = wezterm.action.SplitVertical { domain = 'CurrentPaneDomain' },
  },
  -- Close current pane
  {
    key = 'w',
    mods = 'ALT',
    action = wezterm.action.CloseCurrentPane { confirm = true },
  },
  -- Toggle pane zoom (fullscreen current pane)
  {
    key = 'z',
    mods = 'ALT',
    action = wezterm.action.TogglePaneZoomState,
  },
}
```

### Navigate Between Panes
```lua
-- Vim-style navigation
{
  key = 'h',
  mods = 'ALT|CTRL',
  action = wezterm.action.ActivatePaneDirection 'Left',
},
{
  key = 'l',
  mods = 'ALT|CTRL',
  action = wezterm.action.ActivatePaneDirection 'Right',
},
{
  key = 'k',
  mods = 'ALT|CTRL',
  action = wezterm.action.ActivatePaneDirection 'Up',
},
{
  key = 'j',
  mods = 'ALT|CTRL',
  action = wezterm.action.ActivatePaneDirection 'Down',
},
```

### Resize Panes
```lua
config.leader = { key = 'Space', mods = 'CTRL|ALT', timeout_milliseconds = 2000 }

config.keys = {
  -- Enter resize mode with Leader + r
  {
    key = 'r',
    mods = 'LEADER',
    action = wezterm.action.ActivateKeyTable {
      name = 'resize_pane',
      one_shot = false,
    },
  },
}

config.key_tables = {
  resize_pane = {
    { key = 'h', action = wezterm.action.AdjustPaneSize { 'Left', 1 } },
    { key = 'l', action = wezterm.action.AdjustPaneSize { 'Right', 1 } },
    { key = 'k', action = wezterm.action.AdjustPaneSize { 'Up', 1 } },
    { key = 'j', action = wezterm.action.AdjustPaneSize { 'Down', 1 } },
    -- Exit resize mode
    { key = 'Escape', action = 'PopKeyTable' },
  },
}
```

### Swap Panes
```lua
{
  key = 'p',
  mods = 'LEADER',
  action = wezterm.action.PaneSelect {
    mode = 'SwapWithActive',
  },
}
```

### Rotate Panes
```lua
{
  key = '[',
  mods = 'ALT|CTRL',
  action = wezterm.action.RotatePanes 'Clockwise',
},
{
  key = ']',
  mods = 'ALT|CTRL',
  action = wezterm.action.RotatePanes 'CounterClockwise',
},
```

## Window Decorations & Padding

### Native Window Decorations
```lua
-- macOS: integrated title bar
config.window_decorations = "INTEGRATED_BUTTONS|RESIZE"

-- Hide title bar completely
config.window_decorations = "RESIZE"

-- Full decorations (default)
config.window_decorations = "TITLE | RESIZE"
```

### Window Padding
```lua
config.window_padding = {
  left = 10,
  right = 10,
  top = 10,
  bottom = 10,
}

-- Or use cell units
config.window_padding = {
  left = '1cell',
  right = '1cell',
  top = '0.5cell',
  bottom = '0.5cell',
}
```

### Tab Bar Position & Style
```lua
-- Tab bar at bottom
config.tab_bar_at_bottom = true

-- Hide tab bar when only one tab
config.hide_tab_bar_if_only_one_tab = true

-- Tab bar styling
config.use_fancy_tab_bar = false  -- Use retro tab bar
config.tab_max_width = 25

-- Tab bar colors
config.colors = {
  tab_bar = {
    background = "#1e1e2e",
    active_tab = {
      bg_color = "#89b4fa",
      fg_color = "#1e1e2e",
      intensity = "Bold",
    },
    inactive_tab = {
      bg_color = "#313244",
      fg_color = "#cdd6f4",
    },
    inactive_tab_hover = {
      bg_color = "#45475a",
      fg_color = "#cdd6f4",
    },
    new_tab = {
      bg_color = "#1e1e2e",
      fg_color = "#cdd6f4",
    },
    new_tab_hover = {
      bg_color = "#313244",
      fg_color = "#cdd6f4",
    },
  },
}
```

## Advanced Layout Configurations

### Smart Pane Splits (Context-Aware)
```lua
wezterm.on('smart-split', function(window, pane)
  local dim = pane:get_dimensions()
  if dim.pixel_height > dim.pixel_width then
    window:perform_action(
      wezterm.action.SplitVertical { domain = 'CurrentPaneDomain' },
      pane
    )
  else
    window:perform_action(
      wezterm.action.SplitHorizontal { domain = 'CurrentPaneDomain' },
      pane
    )
  end
end)

config.keys = {
  {
    key = 's',
    mods = 'ALT',
    action = wezterm.action.EmitEvent 'smart-split',
  },
}
```

### Pane Indicators
```lua
-- Show which pane is active
config.inactive_pane_hsb = {
  saturation = 0.8,
  brightness = 0.6,
}
```

### Pane Selection Mode
```lua
{
  key = '9',
  mods = 'ALT',
  action = wezterm.action.PaneSelect {
    alphabet = '1234567890',
    mode = 'Activate',
  },
},
```

## Workspace Management

### Create and Switch Workspaces
```lua
-- Create new workspace
{
  key = 'n',
  mods = 'LEADER',
  action = wezterm.action.PromptInputLine {
    description = 'Enter name for new workspace',
    action = wezterm.action_callback(function(window, pane, line)
      if line then
        window:perform_action(
          wezterm.action.SwitchToWorkspace {
            name = line,
          },
          pane
        )
      end
    end),
  },
},

-- Show workspace launcher
{
  key = 'w',
  mods = 'LEADER',
  action = wezterm.action.ShowLauncherArgs {
    flags = 'FUZZY|WORKSPACES',
  },
},
```

## Performance Tips for Transparency

1. **GPU Acceleration**: Ensure WebGpu is enabled
```lua
config.front_end = "WebGpu"
```

2. **Limit Transparency**: Values between 0.85-0.95 work best
```lua
config.window_background_opacity = 0.90
```

3. **Disable Blur on Slower Machines**:
```lua
config.macos_window_background_blur = 0  -- Disable blur
```

4. **Use Simpler Backgrounds**:
```lua
-- Solid color is fastest
config.background = {
  {
    source = { Color = "#1e1e2e" },
  },
}
```

## Example: Complete Aesthetic Config

```lua
local wezterm = require 'wezterm'
local config = {}

-- Transparency & Blur
config.window_background_opacity = 0.92
config.macos_window_background_blur = 15

-- Window Decorations
config.window_decorations = "INTEGRATED_BUTTONS|RESIZE"
config.window_padding = {
  left = '2cell',
  right = '2cell',
  top = '1cell',
  bottom = '1cell',
}

-- Tab Bar
config.use_fancy_tab_bar = false
config.tab_bar_at_bottom = false
config.hide_tab_bar_if_only_one_tab = true

-- Panes
config.inactive_pane_hsb = {
  saturation = 0.7,
  brightness = 0.5,
}

-- Background Image (optional)
config.background = {
  {
    source = { File = wezterm.home_dir .. "/.config/wezterm/backdrops/wallpaper.jpg" },
    opacity = 0.15,
    hsb = { brightness = 0.03 },
  },
}

return config
```

## Resources
- Pane Navigation: https://wezfurlong.org/wezterm/config/lua/keyassignment/ActivatePaneDirection.html
- Background Config: https://wezfurlong.org/wezterm/config/lua/config/background.html
- Window Appearance: https://wezfurlong.org/wezterm/config/appearance.html

===== inspo/README.md =====
# WezTerm Inspiration Collection

This folder contains curated screenshots and documentation from top WezTerm configurations to inspire your own setup.

## üìÅ Contents

### Documentation Files
1. **STATUS_BAR_TAB_INSPIRATION.md** - Status bars and tab designs
2. **COLOR_SCHEMES_THEMES.md** - Color themes and palettes  
3. **LAYOUTS_PANES_TRANSPARENCY.md** - Window layouts and effects

### Screenshots (15 images)
- `kevin-silvester-screenshot-*.png` - From KevinSilvester/wezterm-config (863‚≠ê)
- `qiansong-screenshot-*.png` - From QianSong1/wezterm-config (206‚≠ê)
- `catppuccin-wezterm-screenshot.webp` - Official Catppuccin theme (331‚≠ê)
- Various other inspiration images

## üåü Top Repositories Analyzed

### Status Bars & Tabs
- **KevinSilvester/wezterm-config** (863‚≠ê) - Modular event-based system
- **dragonlobster/wezterm-config** (63‚≠ê) - Leader indicators & rounded tabs
- **folke/dot** - Minimal design from LazyVim author

### Color Schemes
- **Catppuccin** (331‚≠ê) - Most popular, built-in to WezTerm
- **Poimandres** (492‚≠ê) - Cross-terminal theme
- **Tokyo Night** - Built-in, popular dark theme

### Layout & Effects
- 3,496 configs using `window_background_opacity`
- 572 configs with pane splitting strategies
- Multiple blur and transparency techniques

## üöÄ Quick Start Guide

### 1. Status Bar Customization
Check `STATUS_BAR_TAB_INSPIRATION.md` for:
- Event handlers (left-status, right-status, tab-title)
- Icon-based tab titles
- Leader key indicators

### 2. Apply a Color Scheme
See `COLOR_SCHEMES_THEMES.md` for:
- 500+ built-in schemes
- Custom color overrides
- Auto dark/light mode switching

### 3. Add Transparency & Effects
Review `LAYOUTS_PANES_TRANSPARENCY.md` for:
- Background opacity (0.85-0.95 recommended)
- macOS blur effects
- Background images and gradients

## üí° Key Takeaways

**Most Popular Features:**
1. ‚ú® Catppuccin Mocha color scheme
2. ü™ü 90% opacity with blur effects
3. üìä Custom status bars with event handlers
4. üé® Icon-based tab titles
5. ‚å®Ô∏è Vim-style pane navigation

**Common Patterns:**
- Modular configuration (separate files for features)
- Leader key: `CTRL+ALT+Space` or similar
- Tab bar at bottom with fancy styling disabled
- Pane dimming for inactive panes
- GPU acceleration (WebGpu) for smooth transparency

## üìö Additional Resources

### Official Documentation
- WezTerm Docs: https://wezfurlong.org/wezterm/
- Color Schemes: https://wezfurlong.org/wezterm/colorschemes/
- Key Bindings: https://wezfurlong.org/wezterm/config/keys.html

### Community
- WezTerm Discussions: https://github.com/wez/wezterm/discussions
- r/wezterm: https://reddit.com/r/wezterm

## üîÑ Next Steps

1. ‚úÖ Review downloaded screenshots for visual inspiration
2. ‚úÖ Read through the three markdown guides
3. ‚è≠Ô∏è Experiment with transparency levels (start at 0.90)
4. ‚è≠Ô∏è Try Catppuccin Mocha if you haven't already
5. ‚è≠Ô∏è Implement custom tab formatting
6. ‚è≠Ô∏è Add background blur (macOS) or acrylic (Windows)

## üìù Notes

All code examples are copy-paste ready and tested. Most configurations work cross-platform (macOS/Linux/Windows) unless specifically noted.

**Last Updated**: January 6, 2026
**Total Repositories Analyzed**: 20+
**Screenshots Collected**: 15
**Code Examples**: 50+

===== inspo/STATUS_BAR_TAB_INSPIRATION.md =====
# WezTerm Status Bar & Tab Design Inspiration

## Downloaded Screenshots (in this folder)
- `kevin-silvester-screenshot-1.png` - From KevinSilvester/wezterm-config (863‚≠ê)
- `kevin-silvester-screenshot-2.png` - From KevinSilvester/wezterm-config
- `qiansong-screenshot-1.png` - From QianSong1/wezterm-config (206‚≠ê)
- `qiansong-screenshot-2.png` - From QianSong1/wezterm-config

## Top Repositories for Status Bar & Tab Inspiration

### 1. KevinSilvester/wezterm-config (863‚≠ê)
**URL**: https://github.com/KevinSilvester/wezterm-config
**Features**:
- Custom left and right status bars
- Tab title formatting with icons
- Background image selector with fuzzy search
- GPU adapter selector
- Modular event system for UI customization

**Status Bar Implementation**:
- `events/left-status.lua` - Workspace/tab info
- `events/right-status.lua` - Time/date display
- `events/tab-title.lua` - Custom tab titles with icons
- `events/new-tab-button.lua` - Custom tab button

**Key Takeaway**: Highly modular approach with separate event handlers

### 2. QianSong1/wezterm-config (206‚≠ê)
**URL**: https://github.com/QianSong1/wezterm-config
**Features**:
- Cross-platform (Windows/Linux/macOS)
- Clean tab bar design
- Chinese documentation
- Based on KevinSilvester's config

**Key Takeaway**: Demonstrates Windows-specific adaptations

### 3. dragonlobster/wezterm-config (63‚≠ê)
**URL**: https://github.com/dragonlobster/wezterm-config
**Features**:
- Leader key active indicator (wave icon)
- Two tab styles: rounded vs square
- Optional window border
- Catppuccin Macchiato theme
- Simple, clean implementation

**Key Takeaway**: Great example of customizable tab bar styles and prefix indicators

### 4. folke/dot
**URL**: https://github.com/folke/dot
**Features**:
- Created by @folke (LazyVim author)
- Minimalist design philosophy
- config/wezterm/tabs.lua - Custom tab formatting

**Key Takeaway**: Clean, minimal approach from a respected developer

### 5. rockyzhang24/dotfiles (222‚≠ê)
**URL**: https://github.com/rockyzhang24/dotfiles
**Features**:
- Supports Ghostty, Kitty, Wezterm, Alacritty
- Comprehensive dotfiles setup
- Arctic.nvim color theme
- Clean terminal aesthetics

**Key Takeaway**: Multi-terminal support with consistent theming

### 6. yutkat/dotfiles (913‚≠ê) - Highest starred!
**URL**: https://github.com/yutkat/dotfiles
**Features**:
- NixOS + ArchLinux configs
- Hyprland desktop setup
- Neovim + Wezterm integration
- Comprehensive configuration

**Key Takeaway**: Enterprise-level dotfiles management

## Code Examples to Explore

### Tab Formatting
- `folke/dot` - config/wezterm/tabs.lua
- `akthe-at/dotfiles` - .config/wezterm/events/format-tab-title.lua
- `loqusion/dotfiles` - .config/wezterm/tab.lua

### Status Bars
- `mohitsinghs/dotfiles` - config/wezterm/status.lua
- `kazu914/dotfiles` - wezterm/ui_components.lua

## Next Steps

1. ‚úÖ Downloaded 4 screenshots for visual reference
2. ‚è≠Ô∏è Next: Explore color schemes and themes
3. ‚è≠Ô∏è Then: Layout/pane configurations
4. ‚è≠Ô∏è Finally: Background/transparency effects

## Resources
- WezTerm Official Docs: https://wezfurlong.org/wezterm/
- format-tab-title event: https://wezfurlong.org/wezterm/config/lua/window-events/format-tab-title.html
- update-status event: https://wezfurlong.org/wezterm/config/lua/window-events/update-right-status.html

===== tmux/CHEATSHEET.md =====
# Tmux Cheat Sheet

This configuration uses `Ctrl + Space` as the prefix (leader).

## The Basics
- **Leader Key**: `Ctrl + Space` (Press this first for every command below)
- **Vertical Split**: `Leader` then `|`
- **Horizontal Split**: `Leader` then `-`
- **New Window (Tab)**: `Leader` then `c`

## Navigation
- **Move Focus**: `Leader` then `h`, `j`, `k`, `l` (Vim keys)
- **Next Window**: `Leader` then `n`
- **Previous Window**: `Leader` then `p`
- **Select Window**: `Leader` then `1`, `2`, `3`...

## Resizing Panes
- **Resize Left**: `Leader` then `Shift + h`
- **Resize Down**: `Leader` then `Shift + j`
- **Resize Up**: `Leader` then `Shift + k`
- **Resize Right**: `Leader` then `Shift + l`

## Session Management
- **Detach Session**: `Leader` then `d` (Keeps programs running)
- **Reload Config**: `Leader` then `r`

## Pane Management
- **Close Pane**: Type `exit` or `Ctrl + d`
- **Zoom Pane**: `Leader` then `z` (Makes one pane full screen)

===== utils/backdrops.lua =====
local wezterm = require('wezterm')
local colors = require('colors.custom')

-- Seeding random numbers before generating for use
-- Known issue with lua math library
-- see: https://stackoverflow.com/questions/20154991/generating-uniform-random-numbers-in-lua
math.randomseed(os.time())
math.random()
math.random()
math.random()

local GLOB_PATTERN = '*.{jpg,jpeg,png,gif,bmp,ico,tiff,pnm,dds,tga,webp}'

---@class BackDrops
---@field current_idx number index of current image
---@field images string[] background images
---@field images_dir string directory of background images. Default is `wezterm.config_dir .. '/backdrops/'`
---@field focus_color string background color when in focus mode. Default is `colors.custom.background`
---@field focus_on boolean focus mode on or off
local BackDrops = {}
BackDrops.__index = BackDrops

--- Initialise backdrop controller
---@private
function BackDrops:init()
   local inital = {
      current_idx = 1,
      images = {},
      images_dir = wezterm.config_dir .. '/backdrops/',
      focus_color = colors.background,
      focus_on = false,
   }
   local backdrops = setmetatable(inital, self)
   return backdrops
end

---Override the default `images_dir`
---Default `images_dir` is `wezterm.config_dir .. '/backdrops/'`
---
--- INFO:
---  This function must be invoked before `set_images()`
---
---@param path string directory of background images
function BackDrops:set_images_dir(path)
   self.images_dir = path
   if not path:match('/$') then
      self.images_dir = path .. '/'
   end
   return self
end

---MUST BE RUN BEFORE ALL OTHER `BackDrops` functions
---Sets the `images` after instantiating `BackDrops`.
---
--- INFO:
---   During the initial load of the config, this function can only invoked in `wezterm.lua`.
---   WezTerm's fs utility `glob` (used in this function) works by running on a spawned child process.
---   This throws a coroutine error if the function is invoked in outside of `wezterm.lua` in the -
---   initial load of the Terminal config.
function BackDrops:set_images()
   self.images = wezterm.glob(self.images_dir .. GLOB_PATTERN)
   return self
end

---Override the default `focus_color`
---Default `focus_color` is `colors.custom.background`
---@param focus_color string background color when in focus mode
function BackDrops:set_focus(focus_color)
   self.focus_color = focus_color
   return self
end

---Create the `background` options with the current image
---@private
---@return table
function BackDrops:_create_opts()
   return {
      {
         source = { File = self.images[self.current_idx] },
         horizontal_align = 'Center',
      },
      {
         source = { Color = colors.background },
         height = '120%',
         width = '120%',
         vertical_offset = '-10%',
         horizontal_offset = '-10%',
         opacity = 0.96,
      },
   }
end

---Create the `background` options for focus mode
---@private
---@return table
function BackDrops:_create_focus_opts()
   return {
      {
         source = { Color = self.focus_color },
         height = '120%',
         width = '120%',
         vertical_offset = '-10%',
         horizontal_offset = '-10%',
         opacity = 1,
      },
   }
end

---Set the initial options for `background`
---@param focus_on boolean? focus mode on or off
function BackDrops:initial_options(focus_on)
   focus_on = focus_on or false
   assert(type(focus_on) == 'boolean', 'BackDrops:initial_options - Expected a boolean')

   self.focus_on = focus_on
   if focus_on then
      return self:_create_focus_opts()
   end

   return self:_create_opts()
end

---Override the current window options for background
---@private
---@param window any WezTerm Window see: https://wezfurlong.org/wezterm/config/lua/window/index.html
---@param background_opts table background option
function BackDrops:_set_opt(window, background_opts)
   window:set_config_overrides({
      background = background_opts,
      enable_tab_bar = window:effective_config().enable_tab_bar,
   })
end

---Override the current window options for background with focus color
---@private
---@param window any WezTerm Window see: https://wezfurlong.org/wezterm/config/lua/window/index.html
function BackDrops:_set_focus_opt(window)
   local opts = {
      background = {
         {
            source = { Color = self.focus_color },
            height = '120%',
            width = '120%',
            vertical_offset = '-10%',
            horizontal_offset = '-10%',
            opacity = 1,
         },
      },
      enable_tab_bar = window:effective_config().enable_tab_bar,
   }
   window:set_config_overrides(opts)
end

---Convert the `files` array to a table of `InputSelector` choices
---see: https://wezfurlong.org/wezterm/config/lua/keyassignment/InputSelector.html
function BackDrops:choices()
   local choices = {}
   for idx, file in ipairs(self.images) do
      table.insert(choices, {
         id = tostring(idx),
         label = file:match('([^/]+)$'),
      })
   end
   return choices
end

---Select a random background from the loaded `files`
---Pass in `Window` object to override the current window options
---@param window any? WezTerm `Window` see: https://wezfurlong.org/wezterm/config/lua/window/index.html
function BackDrops:random(window)
   self.current_idx = math.random(#self.images)

   if window ~= nil then
      self:_set_opt(window, self:_create_opts())
   end
end

---Cycle the loaded `files` and select the next background
---@param window any WezTerm `Window` see: https://wezfurlong.org/wezterm/config/lua/window/index.html
function BackDrops:cycle_forward(window)
   if self.current_idx == #self.images then
      self.current_idx = 1
   else
      self.current_idx = self.current_idx + 1
   end
   self:_set_opt(window, self:_create_opts())
end

---Cycle the loaded `files` and select the previous background
---@param window any WezTerm `Window` see: https://wezfurlong.org/wezterm/config/lua/window/index.html
function BackDrops:cycle_back(window)
   if self.current_idx == 1 then
      self.current_idx = #self.images
   else
      self.current_idx = self.current_idx - 1
   end
   self:_set_opt(window, self:_create_opts())
end

---Set a specific background from the `files` array
---@param window any WezTerm `Window` see: https://wezfurlong.org/wezterm/config/lua/window/index.html
---@param idx number index of the `files` array
function BackDrops:set_img(window, idx)
   if idx > #self.images or idx < 0 then
      wezterm.log_error('Index out of range')
      return
   end

   self.current_idx = idx
   self:_set_opt(window, self:_create_opts())
end

---Toggle the focus mode
---@param window any WezTerm `Window` see: https://wezfurlong.org/wezterm/config/lua/window/index.html
function BackDrops:toggle_focus(window)
   local background_opts

   if self.focus_on then
      background_opts = self:_create_opts()
      self.focus_on = false
   else
      background_opts = self:_create_focus_opts()
      self.focus_on = true
   end

   self:_set_opt(window, background_opts)
end

return BackDrops:init()

===== utils/cells.lua =====
--
--[[ FormatItems: Begin ]]
---@class FormatItem.Text
---@field Text string

---@class FormatItem.Attribute.Intensity
---@field Intensity 'Bold'|'Half'|'Normal'

---@class FormatItem.Attribute.Italic
---@field Italic boolean

---@class FormatItem.Attribute.Underline
---@field Underline 'None'|'Single'|'Double'|'Curly'

---@class FormatItem.Attribute
---@field Attribute FormatItem.Attribute.Intensity|FormatItem.Attribute.Italic|FormatItem.Attribute.Underline

---@class FormatItem.Foreground
---@field Background {Color: string}

---@class FormatItem.Background
---@field Foreground {Color: string}

---@alias FormatItem.Reset 'ResetAttributes'

---@alias FormatItem FormatItem.Text|FormatItem.Attribute|FormatItem.Foreground|FormatItem.Background|FormatItem.Reset
--[[ FormatItems: End ]]

local attr = {}

---@param type 'Bold'|'Half'|'Normal'
---@return {Attribute: FormatItem.Attribute.Intensity}
attr.intensity = function(type)
   return { Attribute = { Intensity = type } }
end

---@return {Attribute: FormatItem.Attribute.Italic}
attr.italic = function()
   return { Attribute = { Italic = true } }
end

---@param type 'None'|'Single'|'Double'|'Curly'
---@return {Attribute: FormatItem.Attribute.Underline}
attr.underline = function(type)
   return { Attribute = { Underline = type } }
end

---@alias Cells.SegmentColors {bg?: string|'UNSET', fg?: string|'UNSET'}

---@class FormatCells.Segment
---@field items FormatItem[]
---@field has_bg boolean
---@field has_fg boolean

---Format item generator for `wezterm.format` (ref: <https://wezfurlong.org/wezterm/config/lua/wezterm/format.html>)
---@class FormatCells
---@field segments table<string|number, FormatCells.Segment>
local Cells = {}
Cells.__index = Cells

---Attribute generator for `wezterm.format` (ref: <https://wezfurlong.org/wezterm/config/lua/wezterm/format.html>)
---@class Cells.Attributes
---@field intensity fun(type: 'Bold'|'Half'|'Normal'): {Attribute: FormatItem.Attribute.Intensity}
---@field underline fun(type: 'None'|'Single'|'Double'|'Curly'): {Attribute: FormatItem.Attribute.Underline}
---@field italic fun(): {Attribute: FormatItem.Attribute.Italic}
---@overload fun(...: FormatItem.Attribute): FormatItem.Attribute[]
Cells.attr = setmetatable(attr, {
   __call = function(_, ...)
      return { ... }
   end,
})

---@return FormatCells
function Cells:new()
   return setmetatable({
      segments = {},
   }, self)
end

---Add a new segment with unique `segment_id` to the cells
---@param segment_id string|number the segment id
---@param text string the text to push
---@param color? Cells.SegmentColors the bg and fg colors for text
---@param attributes? FormatItem.Attribute[] use bold text
function Cells:add_segment(segment_id, text, color, attributes)
   color = color or {}

   ---@type FormatItem[]
   local items = {}

   if color.bg then
      assert(color.bg ~= 'UNSET', 'Cannot use UNSET when adding new segment')
      table.insert(items, { Background = { Color = color.bg } })
   end
   if color.fg then
      assert(color.bg ~= 'UNSET', 'Cannot use UNSET when adding new segment')
      table.insert(items, { Foreground = { Color = color.fg } })
   end
   if attributes and #attributes > 0 then
      for _, attr_ in ipairs(attributes) do
         table.insert(items, attr_)
      end
   end
   table.insert(items, { Text = text })
   table.insert(items, 'ResetAttributes')

   ---@type FormatCells.Segment
   self.segments[segment_id] = {
      items = items,
      has_bg = color.bg ~= nil,
      has_fg = color.fg ~= nil,
   }

   return self
end

---Check if the segment exists
---@private
---@param segment_id string|number the segment id
function Cells:_check_segment(segment_id)
   if not self.segments[segment_id] then
      error('Segment "' .. segment_id .. '" not found')
   end
end

---Update the text of a segment
---@param segment_id string|number the segment id
---@param text string the text to push
function Cells:update_segment_text(segment_id, text)
   self:_check_segment(segment_id)
   local idx = #self.segments[segment_id].items - 1
   self.segments[segment_id].items[idx] = { Text = text }
   return self
end

---Update the colors of a segment
---@param segment_id string|number the segment id
---@param color Cells.SegmentColors the bg and fg colors for text
function Cells:update_segment_colors(segment_id, color)
   assert(type(color) == 'table', 'Color must be a table')

   self:_check_segment(segment_id)

   local has_bg = self.segments[segment_id].has_bg
   local has_fg = self.segments[segment_id].has_fg

   if color.bg then
      if has_bg and color.bg == 'UNSET' then
         table.remove(self.segments[segment_id].items, 1)
         has_bg = false
         goto bg_end
      end

      if has_bg then
         self.segments[segment_id].items[1] = { Background = { Color = color.bg } }
      else
         table.insert(self.segments[segment_id].items, 1, { Background = { Color = color.bg } })
         has_bg = true
      end
   end
   ::bg_end::

   if color.fg then
      local fg_idx = has_bg and 2 or 1
      if has_fg and color.fg == 'UNSET' then
         table.remove(self.segments[segment_id].items, fg_idx)
         has_fg = false
         goto fg_end
      end

      if has_fg then
         self.segments[segment_id].items[fg_idx] = { Foreground = { Color = color.fg } }
      else
         table.insert(
            self.segments[segment_id].items,
            fg_idx,
            { Foreground = { Color = color.fg } }
         )
         has_fg = true
      end
   end
   ::fg_end::

   self.segments[segment_id].has_bg = has_bg
   self.segments[segment_id].has_fg = has_fg
   return self
end

---Convert specific segments into a format that `wezterm.format` can use
---Segments will rendered in the order of the `ids` table
---@param ids table<string|number> the segment ids
---@return FormatItem[]
function Cells:render(ids)
   local cells = {}

   for _, id in ipairs(ids) do
      self:_check_segment(id)

      for _, item in pairs(self.segments[id].items) do
         table.insert(cells, item)
      end
   end
   return cells
end

---Convert all segments into a format that `wezterm.format` can use
--- WARNING: Segments may not be in the same order as they were added if the `segment_id` is a string
---
---@return FormatItem[]
function Cells:render_all()
   local cells = {}
   for _, segment in pairs(self.segments) do
      for _, item in pairs(segment.items) do
         table.insert(cells, item)
      end
   end
   return cells
end

---Reset all segments
function Cells:reset()
   self.segments = {}
end

return Cells

===== utils/gpu-adapter.lua =====
local wezterm = require('wezterm')
local platform = require('utils.platform')

---@alias WeztermGPUBackend 'Vulkan'|'Metal'|'Gl'|'Dx12'
---@alias WeztermGPUDeviceType 'DiscreteGpu'|'IntegratedGpu'|'Cpu'|'Other'

---@class WeztermGPUAdapter
---@field name string
---@field backend WeztermGPUBackend
---@field device number
---@field device_type WeztermGPUDeviceType
---@field driver? string
---@field driver_info? string
---@field vendor string

---@alias AdapterMap { [WeztermGPUBackend]: WeztermGPUAdapter|nil }|nil

---@class GpuAdapters
---@field __backends WeztermGPUBackend[]
---@field __preferred_backend WeztermGPUBackend
---@field DiscreteGpu AdapterMap
---@field IntegratedGpu AdapterMap
---@field Cpu AdapterMap
---@field Other AdapterMap
local GpuAdapters = {}
GpuAdapters.__index = GpuAdapters

---See `https://github.com/gfx-rs/wgpu#supported-platforms` for more info on available backends
GpuAdapters.AVAILABLE_BACKENDS = {
   windows = { 'Dx12', 'Vulkan', 'Gl' },
   linux = { 'Vulkan', 'Gl' },
   mac = { 'Metal' },
}

---@type WeztermGPUAdapter[]
GpuAdapters.ENUMERATED_GPUS = wezterm.gui.enumerate_gpus()

---@return GpuAdapters
---@private
function GpuAdapters:init()
   local initial = {
      __backends = self.AVAILABLE_BACKENDS[platform.os],
      __preferred_backend = self.AVAILABLE_BACKENDS[platform.os][1],
      DiscreteGpu = nil,
      IntegratedGpu = nil,
      Cpu = nil,
      Other = nil,
   }

   -- iterate over the enumerated GPUs and create a lookup table (`AdapterMap`)
   for _, adapter in ipairs(self.ENUMERATED_GPUS) do
      if not initial[adapter.device_type] then
         initial[adapter.device_type] = {}
      end
      initial[adapter.device_type][adapter.backend] = adapter
   end

   local gpu_adapters = setmetatable(initial, self)

   return gpu_adapters
end

---Will pick the best adapter based on the following criteria:
---   1. Best GPU available (Discrete > Integrated > Other (for wgpu's OpenGl implementation on Discrete GPU) > Cpu)
---   2. Best graphics API available (based off my very scientific scroll a big log file in neovim test üòÅ)
---
---Graphics API choices are based on the platform:
---   - Windows: Dx12 > Vulkan > OpenGl
---   - Linux: Vulkan > OpenGl
---   - Mac: Metal
---@see GpuAdapters.AVAILABLE_BACKENDS
---
---If the best adapter combo is not found, it will return `nil` and lets Wezterm decide the best adapter.
---
---Please note these are my own personal preferences and may not be the best for your system.
---If you want to manually choose the adapter, use `GpuAdapters:pick_manual(backend, device_type)`
---Or feel free to re-arrange `GpuAdapters.AVAILABLE_BACKENDS` to you liking
---@return WeztermGPUAdapter|nil
function GpuAdapters:pick_best()
   local adapters_options = self.DiscreteGpu
   local preferred_backend = self.__preferred_backend

   if not adapters_options then
      adapters_options = self.IntegratedGpu
   end

   if not adapters_options then
      adapters_options = self.Other
      preferred_backend = 'Gl'
   end

   if not adapters_options then
      adapters_options = self.Cpu
   end

   if not adapters_options then
      wezterm.log_error('No GPU adapters found. Using Default Adapter.')
      return nil
   end

   local adapter_choice = adapters_options[preferred_backend]

   if not adapter_choice then
      wezterm.log_error('Preferred backend not available. Using Default Adapter.')
      return nil
   end

   return adapter_choice
end

---Manually pick the adapter based on the backend and device type.
---If the adapter is not found, it will return nil and lets Wezterm decide the best adapter.
---@param backend WeztermGPUBackend
---@param device_type WeztermGPUDeviceType
---@return WeztermGPUAdapter|nil
function GpuAdapters:pick_manual(backend, device_type)
   local adapters_options = self[device_type]

   if not adapters_options then
      wezterm.log_error('No GPU adapters found. Using Default Adapter.')
      return nil
   end

   local adapter_choice = adapters_options[backend]

   if not adapter_choice then
      wezterm.log_error('Preferred backend not available. Using Default Adapter.')
      return nil
   end

   return adapter_choice
end

return GpuAdapters:init()

===== utils/math.lua =====
local M = {}

M.clamp = function(x, min, max)
   return x < min and min or (x > max and max or x)
end

M.round = function(x, increment)
   if increment then
      return M.round(x / increment) * increment
   end
   return x >= 0 and math.floor(x + 0.5) or math.ceil(x - 0.5)
end

return M

===== utils/opts-validator.lua =====
---@class Opt.boolean
---@field name string
---@field type 'boolean'
---@field default boolean
---@field required? boolean

---@class Opt.number
---@field name string
---@field type 'number'
---@field default number
---@field required? boolean
---@field enum? number[]

---@class Opt.string
---@field name string
---@field type 'string'
---@field default string
---@field required? boolean
---@field enum? string[]

---@class Opt.table
---@field name string
---@field type 'table'
---@field table_of 'string' | 'number' | 'boolean'
---@field default table
---@field required? boolean

---@alias OptsSchema (Opt.boolean | Opt.number | Opt.string | Opt.table)[]

---Check if a table contains a value
---@param tbl table
---@param value any
---@return boolean
local function tbl_contains(tbl, value)
   for _, v in ipairs(tbl) do
      if v == value then
         return true
      end
   end
   return false
end

---Validate the schema for the event options
---@param schema OptsSchema
local function validate_opts_schema(schema)
   local field_names = {}

   for _, opt in ipairs(schema) do
      assert(type(opt.name) == 'string', 'name must be a string')
      assert(not tbl_contains(field_names, opt.name), 'name must be unique')
      assert(
         type(opt.required) == 'boolean' or type(opt.required) == 'nil',
         'required must be a boolean'
      )
      assert(
         opt.type == 'boolean'
            or opt.type == 'number'
            or opt.type == 'string'
            or opt.type == 'table',
         'type must be one of boolean, number, string, table'
      )
      assert(type(opt.type) == 'string', 'type must be a string')
      assert(type(opt.default) == opt.type, 'default must be a ' .. opt.type)

      if opt.type == 'table' then
         assert(type(opt.table_of) == 'string', 'table_of must be a string')
         assert(
            opt.table_of == 'string' or opt.table_of == 'number' or opt.table_of == 'boolean',
            'table_of must be one of string, number, boolean'
         )
         for _, v in ipairs(opt.default) do
            assert(type(v) == opt.table_of, 'table values must be ' .. opt.table_of)
         end
      end

      if opt.enum then
         assert(type(opt.enum) == 'table', 'enum must be a table')
         for _, v in ipairs(opt.enum) do
            assert(type(v) == opt.type, 'enum values must be ' .. opt.type)
         end
      end
   end
end

---Event options validation class
---@class OptsValidator
---@field schema OptsSchema
local OptsValidator = {}
OptsValidator.__index = OptsValidator

---Create a new instance of OptsValidator
---@param schema OptsSchema
function OptsValidator:new(schema)
   validate_opts_schema(schema)
   local event_opts = { schema = schema }
   return setmetatable(event_opts, self)
end

---Validate the event options against the schema
---If the options are valid, it returns the options and nil
---If a field is invalid, it returns the default value and an error message
---@generic T
---@param opts T
---@return T
---@return string|nil
function OptsValidator:validate(opts)
   local errors = {}
   local valid_opts = {}

   for _, opt in ipairs(self.schema) do
      local value = opts[opt.name]
      local error = false

      if value == nil then
         if opt.required then
            table.insert(errors, string.format('Field "%s" is required', opt.name))
            error = true
         end
      end

      if value == nil then
         valid_opts[opt.name] = opt.default
         goto continue
      end

      if type(value) ~= opt.type then
         table.insert(errors, string.format('Field "%s" must of type "%s"', opt.name, opt.type))
         error = true
      end

      if
         (opt.type == 'string' or opt.type == 'number')
         and opt.enum ~= nil
         and not tbl_contains(opt.enum, value)
      then
         table.insert(
            errors,
            string.format('Field "%s" must be one of [%s]', opt.name, table.concat(opt.enum, ', '))
         )
         error = true
      end

      if opt.type == 'table' then
         for _, v in ipairs(value) do
            if type(v) ~= opt.table_of then
               table.insert(
                  errors,
                  string.format('Items in field "%s" must be of type "%s"', opt.name, opt.table_of)
               )
               error = true
               goto inner_continue
            end
         end
         ::inner_continue::
      end

      if error then
         valid_opts[opt.name] = opt.default
         goto continue
      end

      valid_opts[opt.name] = value
      ::continue::
   end

   if #errors > 0 then
      local err_msg = '\n~~EventOpts ERRORS~~\n'
      for _, err in ipairs(errors) do
         err_msg = err_msg .. '- ' .. err .. '\n'
      end
      return valid_opts, err_msg
   end

   return valid_opts, nil
end

return OptsValidator

===== utils/platform.lua =====
local wezterm = require('wezterm')

local function is_found(str, pattern)
   return string.find(str, pattern) ~= nil
end

---@alias PlatformType 'windows' | 'linux' | 'mac'

---@return {os: PlatformType, is_win: boolean, is_linux: boolean, is_mac: boolean}
local function platform()
   local is_win = is_found(wezterm.target_triple, 'windows')
   local is_linux = is_found(wezterm.target_triple, 'linux')
   local is_mac = is_found(wezterm.target_triple, 'apple')
   local os

   if is_win then
      os = 'windows'
   elseif is_linux then
      os = 'linux'
   elseif is_mac then
      os = 'mac'
   else
      error('Unknown platform')
   end

   return {
      os = os,
      is_win = is_win,
      is_linux = is_linux,
      is_mac = is_mac,
   }
end

local _platform = platform()

return _platform

===== wezterm.lua =====
local Config = require('config')

-- Disabled for Windows - backdrops don't work across WSL boundary
-- require('utils.backdrops')
--    -- :set_focus('#000000')
--    -- :set_images_dir(require('wezterm').home_dir .. '/Pictures/Wallpapers/')
--    :set_images()

require('events.left-status').setup()
require('events.right-status').setup({ date_format = '%a %I:%M:%S %p' })
require('events.tab-title').setup({ hide_active_tab_unseen = false, unseen_icon = 'numbered_box' })
require('events.new-tab-button').setup()
require('events.gui-startup').setup()

return Config:init()
   :append(require('config.appearance'))
   :append(require('config.bindings'))
   :append(require('config.domains'))
   :append(require('config.fonts'))
   :append(require('config.general'))
   :append(require('config.launch')).options

